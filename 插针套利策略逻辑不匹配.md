# æ’é’ˆå¥—åˆ©ç­–ç•¥é€»è¾‘ä¸åŒ¹é…

## ğŸ§‘â€ğŸ’» User

E:\Flash_Arbitrage_bot\python\testnet_with_recorder.pyE:\Flash_Arbitrage_bot\python\config\testnet_config.pyE:\Flash_Arbitrage_bot\python\config\__init__.py
ä½ è®¤ä¸ºè¿™äº›è„šæœ¬å­˜åœ¨ä»€ä¹ˆé—®é¢˜ï¼Ÿå¦‚æœè¯´å®é™…ä¸Šè¦å®ç°çš„é€»è¾‘å¦‚åŒå›¾ç‰‡æ‰€ç¤ºå‘¢ï¼Ÿ

---
## ğŸ¤– Assistant

æ ¹æ®å›¾ç‰‡æ˜¾ç¤ºçš„äº¤æ˜“ç­–ç•¥å’Œä»£ç åˆ†æï¼Œæˆ‘å‘ç°äº†å‡ ä¸ªé‡è¦é—®é¢˜ï¼š

## å›¾ç‰‡ä¸­çš„ç­–ç•¥é€»è¾‘

å›¾ç‰‡æè¿°çš„æ˜¯ä¸€ä¸ª**æ’é’ˆå¥—åˆ©ç­–ç•¥**ï¼š
1. **åœ¨æ’é’ˆå·®ä¸å¤šçš„é«˜ä½å…ˆåšç©º** - ä»·æ ¼æ€¥æ¶¨åˆ°3.68æ—¶åšç©º
2. **åœ¨æ’é’ˆå›è°ƒçš„æ—¶å€™ç«‹é©¬åšå¤šé”ä½åˆ©æ¶¦** - ä»·æ ¼å›è°ƒåˆ°3.64æ—¶åšå¤š
3. **åŒå‘æŒä»“** - åŒæ—¶æŒæœ‰å¤šç©ºä»“ä½
4. **å¹³ä»“é¡ºåº** - å…ˆå¼€ç©ºã€åœ¨å¼€å¤šï¼Œé€Ÿåº¦è¦å¿«ï¼›å¹³ä»“å…ˆå¼€ç©ºã€åœ¨å¹³å¤š

åˆ©æ¶¦è®¡ç®—ï¼šç©ºå•èµš0.04 + å¤šå•èµš0.04 = æ€»åˆ©æ¶¦0.08

---

## ä»£ç å­˜åœ¨çš„ä¸»è¦é—®é¢˜

### 1. **ç­–ç•¥é€»è¾‘å®Œå…¨ä¸åŒ¹é…**

å½“å‰ä»£ç çš„é€»è¾‘ï¼š
```python
# å½“å‰ä»£ç ï¼šæ£€æµ‹åˆ°ä¸Šæ’é’ˆ â†’ å¼€ç©ºå•ï¼ˆå•å‘ï¼‰
trade_signal = TradeSignal(
    side="SHORT" if signal.direction == "UP" else "LONG",  # åªå¼€å•å‘
    ...
)
```

å›¾ç‰‡è¦æ±‚çš„é€»è¾‘ï¼š
- æ£€æµ‹åˆ°ä¸Šæ’é’ˆ â†’ **å…ˆå¼€ç©ºå•**
- ç­‰å¾…ä»·æ ¼å›è°ƒ â†’ **å†å¼€å¤šå•**ï¼ˆé”ä½åˆ©æ¶¦ï¼‰
- å½¢æˆ**åŒå‘å¯¹å†²æŒä»“**

### 2. **ç¼ºå°‘åŒå‘æŒä»“æ”¯æŒ**

```python
# å½“å‰é…ç½®
MARGIN_TYPE = "ISOLATED"  # é€ä»“æ¨¡å¼

# éœ€è¦çš„é…ç½®ï¼ˆå›¾ç‰‡ä¸­çš„æ³¨æ„äº‹é¡¹ï¼‰
# 1. å¼€å¯åŒå‘æŒä»“æ¨¡å¼ï¼ˆHedge Modeï¼‰
# 2. å¤šç©ºéƒ½è¦å…ˆå‹¾é€‰ä¸Šæœ€æœ‰ä»·
# 3. ç›¸åŒæ•°é‡çš„å¼€ä»“ä¿è¯é‡‘
```

### 3. **ç¼ºå°‘ä¸¤é˜¶æ®µå…¥åœºæœºåˆ¶**

å½“å‰ä»£ç åªæœ‰å•æ¬¡å…¥åœºï¼Œæ²¡æœ‰ï¼š
- ç¬¬ä¸€é˜¶æ®µï¼šæ’é’ˆé¡¶éƒ¨å¼€ç©º
- ç¬¬äºŒé˜¶æ®µï¼šå›è°ƒåå¼€å¤šï¼ˆé”å®šåˆ©æ¶¦ï¼‰

### 4. **ç¼ºå°‘å¿«é€Ÿæ‰§è¡Œæœºåˆ¶**

å›¾ç‰‡å¼ºè°ƒ"é€Ÿåº¦è¦å¿«"ï¼Œä½†ä»£ç ï¼š
- ä½¿ç”¨æ™®é€šå¸‚ä»·å•
- æ²¡æœ‰å¹¶è¡Œä¸‹å•ä¼˜åŒ–
- æ²¡æœ‰é¢„è®¾è®¢å•æœºåˆ¶

---

## å»ºè®®ä¿®æ”¹æ–¹æ¡ˆ

```python
class HedgeTradeStrategy:
    """åŒå‘å¯¹å†²æ’é’ˆç­–ç•¥"""
    
    def __init__(self):
        self.pending_hedge = {}  # ç­‰å¾…å¯¹å†²çš„ä»“ä½
    
    async def on_pin_signal(self, signal: PinSignal):
        """å¤„ç†æ’é’ˆä¿¡å·"""
        
        if signal.direction == "UP":
            # ç¬¬ä¸€é˜¶æ®µï¼šåœ¨é«˜ç‚¹å¼€ç©º
            await self._open_short(signal)
            
            # è®¾ç½®å›è°ƒç›‘æ§ï¼Œç­‰å¾…å¼€å¤šæ—¶æœº
            self.pending_hedge[signal.symbol] = {
                "short_entry": signal.peak_price,
                "target_long_price": signal.entry_price,  # å›è°ƒç›®æ ‡
                "waiting_for": "LONG"
            }
            
        elif signal.direction == "DOWN":
            # ä¸‹æ’é’ˆï¼šå…ˆå¼€å¤šï¼Œç­‰åå¼¹å¼€ç©º
            await self._open_long(signal)
            self.pending_hedge[signal.symbol] = {
                "long_entry": signal.peak_price,
                "target_short_price": signal.entry_price,
                "waiting_for": "SHORT"
            }
    
    async def on_price_update(self, symbol: str, price: float):
        """ç›‘æ§ä»·æ ¼ï¼Œæ‰§è¡Œå¯¹å†²è…¿"""
        
        if symbol in self.pending_hedge:
            hedge = self.pending_hedge[symbol]
            
            if hedge["waiting_for"] == "LONG":
                # ä»·æ ¼å›è°ƒåˆ°ç›®æ ‡ä½ç½®ï¼Œå¼€å¤šé”å®šåˆ©æ¶¦
                if price <= hedge["target_long_price"]:
                    await self._open_long_hedge(symbol, price)
                    del self.pending_hedge[symbol]
```

### éœ€è¦æ·»åŠ çš„é…ç½®

```python
# testnet_config.py éœ€è¦æ·»åŠ 

# åŒå‘æŒä»“æ¨¡å¼
POSITION_MODE = "Hedge"  # å¯¹å†²æ¨¡å¼ï¼Œæ”¯æŒåŒæ—¶æŒæœ‰å¤šç©º

# å¯¹å†²ç­–ç•¥å‚æ•°
HEDGE_CONFIG = {
    "enable_hedge": True,           # å¯ç”¨å¯¹å†²
    "hedge_wait_timeout": 60,       # ç­‰å¾…å¯¹å†²çš„è¶…æ—¶æ—¶é—´(ç§’)
    "min_hedge_profit": 0.02,       # æœ€å°å¯¹å†²åˆ©æ¶¦ç‡
    "same_quantity": True,          # å¤šç©ºç›¸åŒæ•°é‡
}

# å¹³ä»“é¡ºåº
CLOSE_ORDER = "SHORT_FIRST"  # å…ˆå¹³ç©ºåå¹³å¤š
```

---

## æ€»ç»“é—®é¢˜æ¸…å•

| é—®é¢˜ | ä¸¥é‡ç¨‹åº¦ | è¯´æ˜ |
|------|----------|------|
| å•å‘äº¤æ˜“è€ŒéåŒå‘å¯¹å†² | ğŸ”´ ä¸¥é‡ | å®Œå…¨ä¸ç¬¦åˆå›¾ç‰‡ç­–ç•¥ |
| ç¼ºå°‘å›è°ƒåå¼€å¤šé€»è¾‘ | ğŸ”´ ä¸¥é‡ | åªæœ‰ç¬¬ä¸€é˜¶æ®µå…¥åœº |
| æœªå¯ç”¨Hedgeæ¨¡å¼ | ğŸ”´ ä¸¥é‡ | æ— æ³•åŒæ—¶æŒæœ‰å¤šç©º |
| ç¼ºå°‘å¿«é€Ÿä¸‹å•æœºåˆ¶ | ğŸŸ¡ ä¸­ç­‰ | å½±å“æ‰§è¡Œé€Ÿåº¦ |
| å¹³ä»“é¡ºåºæœªå®šä¹‰ | ğŸŸ¡ ä¸­ç­‰ | å›¾ç‰‡è¦æ±‚å…ˆå¹³ç©ºåå¹³å¤š |
| APIå¯†é’¥ç¡¬ç¼–ç  | ğŸŸ¡ ä¸­ç­‰ | å®‰å…¨é£é™© |

éœ€è¦æˆ‘å¸®ä½ é‡å†™ä¸€ä¸ªç¬¦åˆå›¾ç‰‡ç­–ç•¥çš„å®Œæ•´å®ç°å—ï¼Ÿ

---
## ğŸ§‘â€ğŸ’» User

éœ€è¦ï¼Œä¸”ä¸è¦å˜æ›´é…ç½®ã€‚E:\Flash_Arbitrage_bot\python\test_pin_detector.pyE:\Flash_Arbitrage_bot\python\test_pin_recorder.pyï¼Œæˆ‘é™„ä¸Šäº†å¦å¤–ä¸¤ä¸ªè„šæœ¬çš„å®ç°ï¼Œè¯·ä½ æŸ¥é˜…ã€‚

---
## ğŸ¤– Assistant

æˆ‘ä»”ç»†åˆ†æäº†è¿™äº›è„šæœ¬å’Œå›¾ç‰‡ä¸­çš„ç­–ç•¥ã€‚ç°åœ¨æˆ‘æ¥é‡å†™ä¸€ä¸ªç¬¦åˆå›¾ç‰‡ç­–ç•¥çš„å®Œæ•´å®ç°ã€‚

## å…³é”®ç†è§£

å›¾ç‰‡ä¸­çš„ç­–ç•¥æ ¸å¿ƒæ˜¯ï¼š
1. **åŒå‘å¯¹å†²**ï¼šåœ¨æ’é’ˆé«˜ç‚¹å¼€ç©ºï¼Œå›è°ƒåå¼€å¤šï¼Œå½¢æˆå¯¹å†²
2. **åŒå‘æŒä»“æ¨¡å¼**ï¼šéœ€è¦åŒæ—¶æŒæœ‰å¤šç©ºä»“ä½
3. **é€Ÿåº¦ä¼˜å…ˆ**ï¼šå¼€ä»“å’Œå¹³ä»“éƒ½è¦å¿«
4. **å¹³ä»“é¡ºåº**ï¼šå…ˆå¹³ç©ºï¼Œå†å¹³å¤š

è®©æˆ‘åˆ›å»ºä¸€ä¸ªæ–°çš„é›†æˆè„šæœ¬ï¼š

```python
#!/usr/bin/env python3
"""
æµ‹è¯•ç½‘äº¤æ˜“ä¸æ’é’ˆæ£€æµ‹å™¨é›†æˆ - åŒå‘å¯¹å†²ç­–ç•¥ç‰ˆæœ¬

ç­–ç•¥é€»è¾‘ï¼ˆæ ¹æ®å›¾ç‰‡ï¼‰:
1. æ£€æµ‹åˆ°ä¸Šæ’é’ˆæ—¶ï¼Œåœ¨é«˜ä½å…ˆåšç©º
2. ä»·æ ¼å›è°ƒåˆ°ä¸€å®šç¨‹åº¦æ—¶ï¼Œç«‹é©¬åšå¤šé”ä½åˆ©æ¶¦
3. å½¢æˆåŒå‘å¯¹å†²æŒä»“
4. å¹³ä»“æ—¶ï¼šå…ˆå¹³ç©ºï¼Œå†å¹³å¤š

ä½¿ç”¨æ–¹æ³•:
1. è®¾ç½®ç¯å¢ƒå˜é‡:
export BINANCE_TESTNET_API_KEY=your_api_key
export BINANCE_TESTNET_API_SECRET=your_api_secret

2. è¿è¡Œè„šæœ¬:
python testnet_with_recorder.py
"""

import os
import sys
import time
import signal
import json
import threading
import websocket
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass, field
from collections import deque
from enum import Enum

# æ·»åŠ srcç›®å½•åˆ°è·¯å¾„
script_dir = Path(__file__).parent.resolve()
sys.path.insert(0, str(script_dir / "src"))
sys.path.insert(0, str(script_dir))

# å¯¼å…¥æµ‹è¯•ç½‘äº¤æ˜“ç»„ä»¶
from src.exchange.binance_futures import BinanceFuturesClient
from src.trading.order_manager import OrderManager
from src.trading.position_tracker import PositionTracker
from src.trading.trade_executor import TradeExecutor, TradeSignal
from src.trading.trade_logger import TradeLogger

# å¯¼å…¥é…ç½®
from config.testnet_config import load_config, TestnetConfig


# ============== é…ç½® ==============

# ä»£ç†è®¾ç½®
PROXY_HOST = "127.0.0.1"
PROXY_HTTP_PORT = 7897
USE_PROXY = True

HTTP_PROXY = {
 'http': f'http://{PROXY_HOST}:{PROXY_HTTP_PORT}',
 'https': f'http://{PROXY_HOST}:{PROXY_HTTP_PORT}',
} if USE_PROXY else {}

# æ—¶åŒº
BEIJING_TZ = timezone(timedelta(hours=8))

def get_beijing_time() -> datetime:
 return datetime.now(BEIJING_TZ)

def format_time(dt: datetime = None) -> str:
 if dt is None:
 dt = get_beijing_time()
 return dt.strftime("%H:%M:%S.%f")[:-3]

# WebSocketç«¯ç‚¹ - ä½¿ç”¨æµ‹è¯•ç½‘è¡Œæƒ…
WS_ENDPOINT = "wss://stream.binancefuture.com/ws"

# ç›‘æ§äº¤æ˜“å¯¹
DEFAULT_SYMBOLS = [
 "BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT", "TRUMPUSDT",
 "ZECUSDT", "TAOUSDT", "POLUSDT", "AAVEUSDT"
]

# æ’é’ˆæ£€æµ‹å‚æ•°
SPIKE_CONFIG = {
 "price_window_ms": 1000, # æ£€æµ‹çª—å£1ç§’
 "min_spike_percent": 0.3, # æœ€å°æ’é’ˆå¹…åº¦0.3%
 "max_spike_percent": 5.0, # æœ€å¤§æ’é’ˆå¹…åº¦5.0%
 "retracement_percent": 15, # å›æ’¤è‡³å°‘15%ï¼ˆè§¦å‘ç¬¬ä¸€è…¿ï¼‰
}

# å¯¹å†²ç­–ç•¥å‚æ•°
HEDGE_CONFIG = {
 "enable_hedge": True, # å¯ç”¨å¯¹å†²æ¨¡å¼
 "hedge_retracement_percent": 30, # å›æ’¤30%æ—¶å¼€å¯¹å†²è…¿
 "hedge_wait_timeout_seconds": 60, # ç­‰å¾…å¯¹å†²çš„è¶…æ—¶æ—¶é—´
 "min_profit_to_hedge": 0.02, # æœ€å°ç›ˆåˆ©æ‰å¼€å¯¹å†²ï¼ˆç™¾åˆ†æ¯”ï¼‰
 "same_quantity": True, # å¤šç©ºç›¸åŒæ•°é‡
 "close_order": "SHORT_FIRST", # å¹³ä»“é¡ºåºï¼šå…ˆå¹³ç©º
 "take_profit_after_hedge": 0.5, # å¯¹å†²åæ­¢ç›ˆç‚¹ï¼ˆç™¾åˆ†æ¯”ï¼‰
 "stop_loss_after_hedge": 1.0, # å¯¹å†²åæ­¢æŸç‚¹ï¼ˆç™¾åˆ†æ¯”ï¼‰
}


# ============== æ•°æ®ç±» ==============

class HedgeState(Enum):
 """å¯¹å†²çŠ¶æ€"""
 NONE = "none" # æ— æŒä»“
 FIRST_LEG_OPEN = "first_leg" # ç¬¬ä¸€è…¿å·²å¼€ï¼ˆç­‰å¾…å¯¹å†²ï¼‰
 HEDGED = "hedged" # å·²å¯¹å†²ï¼ˆåŒå‘æŒä»“ï¼‰
 CLOSING = "closing" # æ­£åœ¨å¹³ä»“


@dataclass
class PinSignal:
 """æ’é’ˆä¿¡å·"""
 symbol: str
 direction: str # UP / DOWN
 start_price: float
 peak_price: float
 entry_price: float # ç¬¬ä¸€è…¿å…¥åœºä»·
 amplitude: float # å¹…åº¦ç™¾åˆ†æ¯”
 retracement: float # å›æ’¤ç™¾åˆ†æ¯”
 detected_at: datetime = None
 signal_id: str = ""

 def __post_init__(self):
 if self.detected_at is None:
 self.detected_at = get_beijing_time()
 if not self.signal_id:
 self.signal_id = f"{self.symbol}_{int(self.detected_at.timestamp())}"

 def __str__(self):
 icon = "ğŸ”º" if self.direction == "UP" else "ğŸ”»"
 return f"{self.symbol} {icon} å¹…åº¦:{self.amplitude:.2f}% å›æ’¤:{self.retracement:.1f}%"


@dataclass
class HedgePosition:
 """å¯¹å†²æŒä»“"""
 symbol: str
 signal: PinSignal
 state: HedgeState = HedgeState.NONE

 # ç¬¬ä¸€è…¿ï¼ˆæ’é’ˆæ–¹å‘çš„åå‘ï¼‰
 first_leg_side: str = "" # SHORTï¼ˆä¸Šæ’é’ˆï¼‰æˆ– LONGï¼ˆä¸‹æ’é’ˆï¼‰
 first_leg_entry_price: float = 0.0
 first_leg_quantity: float = 0.0
 first_leg_order_id: str = ""
 first_leg_filled: bool = False
 first_leg_time: datetime = None

 # ç¬¬äºŒè…¿ï¼ˆå¯¹å†²è…¿ï¼‰
 second_leg_side: str = "" # LONGï¼ˆä¸Šæ’é’ˆï¼‰æˆ– SHORTï¼ˆä¸‹æ’é’ˆï¼‰
 second_leg_entry_price: float = 0.0
 second_leg_quantity: float = 0.0
 second_leg_order_id: str = ""
 second_leg_filled: bool = False
 second_leg_time: datetime = None

 # ç›®æ ‡ä»·æ ¼
 hedge_target_price: float = 0.0 # å¼€å¯¹å†²è…¿çš„ç›®æ ‡ä»·æ ¼
 take_profit_price: float = 0.0 # æ­¢ç›ˆä»·æ ¼
 stop_loss_price: float = 0.0 # æ­¢æŸä»·æ ¼

 # ç›ˆäº
 first_leg_pnl: float = 0.0
 second_leg_pnl: float = 0.0
 total_pnl: float = 0.0

 # çŠ¶æ€
 created_at: datetime = None
 closed_at: datetime = None
 close_reason: str = ""

 def __post_init__(self):
 if self.created_at is None:
 self.created_at = get_beijing_time()


# ============== æ’é’ˆæ£€æµ‹å™¨ ==============

class PinDetector:
 """æ’é’ˆæ£€æµ‹å™¨"""

 def __init__(self, symbols: List[str]):
 self.symbols = [s.lower() for s in symbols]
 self.symbols_upper = [s.upper() for s in symbols]
 self.running = False
 self.ws_connected = False

 # æ¯ä¸ªäº¤æ˜“å¯¹çš„ç›‘æ§æ•°æ®
 self.monitors: Dict[str, Dict] = {}
 for s in self.symbols_upper:
 self.monitors[s] = {
 "current_price": 0.0,
 "window_start": 0,
 "window_start_price": 0.0,
 "window_high": 0.0,
 "window_low": float('inf'),
 "last_signal_time": 0,
 "tick_count": 0,
 }

 # å›è°ƒå‡½æ•°
 self.on_signal = None
 self.on_price_update = None

 self.message_count = 0
 self.ws = None
 self.ws_thread = None

 def set_signal_callback(self, callback):
 """è®¾ç½®ä¿¡å·å›è°ƒ"""
 self.on_signal = callback

 def set_price_callback(self, callback):
 """è®¾ç½®ä»·æ ¼æ›´æ–°å›è°ƒ"""
 self.on_price_update = callback

 def start(self):
 """å¯åŠ¨æ£€æµ‹å™¨"""
 self.running = True
 self._connect()

 def stop(self):
 """åœæ­¢æ£€æµ‹å™¨"""
 self.running = False
 if self.ws:
 self.ws.close()

 def _connect(self):
 """è¿æ¥WebSocket"""
 streams = [f"{s}@aggTrade" for s in self.symbols]
 ws_url = f"{WS_ENDPOINT}/{'/'.join(streams)}"

 print(f"[{format_time()}] è¿æ¥WebSocket...")

 self.ws = websocket.WebSocketApp(
 ws_url,
 on_message=self._on_message,
 on_error=self._on_error,
 on_close=self._on_close,
 on_open=self._on_open
 )

 def run_ws():
 if USE_PROXY:
 self.ws.run_forever(
 http_proxy_host=PROXY_HOST,
 http_proxy_port=PROXY_HTTP_PORT,
 proxy_type="http"
 )
 else:
 self.ws.run_forever()

 self.ws_thread = threading.Thread(target=run_ws, daemon=True)
 self.ws_thread.start()

 def _on_open(self, ws):
 self.ws_connected = True
 print(f"[{format_time()}] âœ… WebSocketå·²è¿æ¥")

 def _on_error(self, ws, error):
 if error:
 err_str = str(error)[:80]
 print(f"[{format_time()}] WebSocketé”™è¯¯: {err_str}")

 def _on_close(self, ws, code, msg):
 self.ws_connected = False
 print(f"[{format_time()}] WebSocketæ–­å¼€")
 if self.running:
 print(f"[{format_time()}] 2ç§’åé‡è¿...")
 time.sleep(2)
 self._connect()

 def _on_message(self, ws, message):
 """å¤„ç†ä»·æ ¼æ¶ˆæ¯"""
 try:
 self.message_count += 1
 data = json.loads(message)

 symbol = data.get('s', '').upper()
 if symbol not in self.monitors:
 return

 price = float(data['p'])
 timestamp = datetime.fromtimestamp(data['T'] / 1000, tz=BEIJING_TZ)

 self._process_price(symbol, price, timestamp)
 except Exception as e:
 pass

 def _process_price(self, symbol: str, price: float, timestamp: datetime):
 """å¤„ç†ä»·æ ¼æ›´æ–°"""
 monitor = self.monitors[symbol]
 now_ms = timestamp.timestamp() * 1000

 monitor["current_price"] = price
 monitor["tick_count"] += 1

 # è§¦å‘ä»·æ ¼æ›´æ–°å›è°ƒ
 if self.on_price_update:
 self.on_price_update(symbol, price, timestamp)

 # åˆå§‹åŒ–çª—å£
 if monitor["window_start"] == 0:
 monitor["window_start"] = now_ms
 monitor["window_start_price"] = price
 monitor["window_high"] = price
 monitor["window_low"] = price
 return

 # æ›´æ–°é«˜ä½ç‚¹
 if price > monitor["window_high"]:
 monitor["window_high"] = price
 if price < monitor["window_low"]:
 monitor["window_low"] = price

 # è®¡ç®—çª—å£æ—¶é—´
 window_ms = now_ms - monitor["window_start"]

 # æ£€æµ‹æ’é’ˆ
 if window_ms >= SPIKE_CONFIG["price_window_ms"]:
 self._detect_spike(symbol, price, timestamp, monitor)

 # é‡ç½®çª—å£
 monitor["window_start"] = now_ms
 monitor["window_start_price"] = price
 monitor["window_high"] = price
 monitor["window_low"] = price

 def _detect_spike(self, symbol: str, price: float, timestamp: datetime, monitor: Dict):
 """æ£€æµ‹æ’é’ˆ"""
 start = monitor["window_start_price"]
 high = monitor["window_high"]
 low = monitor["window_low"]

 if start == 0:
 return

 # é˜²æ­¢çŸ­æ—¶é—´å†…é‡å¤ä¿¡å·
 now_ms = timestamp.timestamp() * 1000
 if now_ms - monitor["last_signal_time"] < 5000: # 5ç§’å†·å´
 return

 min_amp = SPIKE_CONFIG["min_spike_percent"]
 max_amp = SPIKE_CONFIG["max_spike_percent"]
 ret_threshold = SPIKE_CONFIG["retracement_percent"]

 signal = None

 # ä¸Šæ’é’ˆæ£€æµ‹
 if high > start:
 up_amp = (high - start) / start * 100
 if min_amp <= up_amp <= max_amp:
 ret = (high - price) / (high - start) * 100
 if ret >= ret_threshold:
 signal = PinSignal(
 symbol=symbol,
 direction="UP",
 start_price=start,
 peak_price=high,
 entry_price=price,
 amplitude=up_amp,
 retracement=ret,
 detected_at=timestamp
 )

 # ä¸‹æ’é’ˆæ£€æµ‹
 if signal is None and start > low:
 down_amp = (start - low) / start * 100
 if min_amp <= down_amp <= max_amp:
 ret = (price - low) / (start - low) * 100
 if ret >= ret_threshold:
 signal = PinSignal(
 symbol=symbol,
 direction="DOWN",
 start_price=start,
 peak_price=low,
 entry_price=price,
 amplitude=down_amp,
 retracement=ret,
 detected_at=timestamp
 )

 if signal:
 monitor["last_signal_time"] = now_ms
 print(f"\nğŸ”” [{format_time()}] æ£€æµ‹åˆ°æ’é’ˆ: {signal}")

 # è§¦å‘å›è°ƒ
 if self.on_signal:
 self.on_signal(signal)

 def get_price(self, symbol: str) -> float:
 """è·å–å½“å‰ä»·æ ¼"""
 if symbol in self.monitors:
 return self.monitors[symbol]["current_price"]
 return 0.0

 def is_connected(self) -> bool:
 return self.ws_connected


# ============== å¯¹å†²äº¤æ˜“ç®¡ç†å™¨ ==============

class HedgeTradeManager:
 """å¯¹å†²äº¤æ˜“ç®¡ç†å™¨

 å®ç°å›¾ç‰‡ä¸­çš„ç­–ç•¥ï¼š
 1. ä¸Šæ’é’ˆ â†’ åœ¨é«˜ä½å¼€ç©º â†’ å›è°ƒåå¼€å¤šé”å®šåˆ©æ¶¦
 2. ä¸‹æ’é’ˆ â†’ åœ¨ä½ä½å¼€å¤š â†’ åå¼¹åå¼€ç©ºé”å®šåˆ©æ¶¦
 3. å¹³ä»“é¡ºåºï¼šå…ˆå¹³ç¬¬ä¸€è…¿ï¼ˆç›ˆåˆ©è…¿ï¼‰ï¼Œå†å¹³ç¬¬äºŒè…¿
 """

 def __init__(self, client: BinanceFuturesClient, config: TestnetConfig):
 self.client = client
 self.config = config

 # æ´»è·ƒçš„å¯¹å†²æŒä»“
 self.active_hedges: Dict[str, HedgePosition] = {}

 # ç­‰å¾…å¯¹å†²çš„æŒä»“
 self.waiting_hedges: Dict[str, HedgePosition] = {}

 # å·²å®Œæˆçš„å¯¹å†²
 self.completed_hedges: List[HedgePosition] = []

 # ç»Ÿè®¡
 self.total_trades = 0
 self.winning_trades = 0
 self.total_pnl = 0.0

 self.lock = threading.Lock()

 def on_pin_signal(self, signal: PinSignal) -> bool:
 """å¤„ç†æ’é’ˆä¿¡å·

 Args:
 signal: æ’é’ˆä¿¡å·

 Returns:
 æ˜¯å¦æˆåŠŸå¼€ä»“
 """
 with self.lock:
 # æ£€æŸ¥æ˜¯å¦å·²æœ‰è¯¥äº¤æ˜“å¯¹çš„æŒä»“
 if signal.symbol in self.active_hedges or signal.symbol in self.waiting_hedges:
 print(f"[{format_time()}] {signal.symbol} å·²æœ‰æŒä»“ï¼Œè·³è¿‡")
 return False

 # åˆ›å»ºå¯¹å†²æŒä»“
 hedge = HedgePosition(
 symbol=signal.symbol,
 signal=signal,
 state=HedgeState.NONE
 )

 # ç¡®å®šç¬¬ä¸€è…¿æ–¹å‘
 if signal.direction == "UP":
 # ä¸Šæ’é’ˆï¼šç¬¬ä¸€è…¿åšç©ºï¼ˆåœ¨é«˜ä½ï¼‰
 hedge.first_leg_side = "SHORT"
 hedge.second_leg_side = "LONG"
 else:
 # ä¸‹æ’é’ˆï¼šç¬¬ä¸€è…¿åšå¤šï¼ˆåœ¨ä½ä½ï¼‰
 hedge.first_leg_side = "LONG"
 hedge.second_leg_side = "SHORT"

 # è®¡ç®—ä»“ä½å¤§å°
 position_usdt = self.config.POSITION_USDT
 leverage = self.config.LEVERAGE

 # å¼€ç¬¬ä¸€è…¿
 success = self._open_first_leg(hedge, signal.entry_price, position_usdt, leverage)

 if success:
 # è®¡ç®—å¯¹å†²ç›®æ ‡ä»·æ ¼
 self._calculate_hedge_targets(hedge, signal)

 with self.lock:
 self.waiting_hedges[signal.symbol] = hedge

 print(f"\nâœ… [{format_time()}] ç¬¬ä¸€è…¿å·²å¼€")
 print(f" äº¤æ˜“å¯¹: {signal.symbol}")
 print(f" æ–¹å‘: {hedge.first_leg_side}")
 print(f" å…¥åœºä»·: {hedge.first_leg_entry_price:.6f}")
 print(f" æ•°é‡: {hedge.first_leg_quantity:.6f}")
 print(f" å¯¹å†²ç›®æ ‡ä»·: {hedge.hedge_target_price:.6f}")

 return True
 else:
 print(f"âŒ [{format_time()}] ç¬¬ä¸€è…¿å¼€ä»“å¤±è´¥: {signal.symbol}")
 return False

 def on_price_update(self, symbol: str, price: float, timestamp: datetime):
 """å¤„ç†ä»·æ ¼æ›´æ–°

 æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å¯¹å†²è…¿æˆ–å¹³ä»“
 """
 with self.lock:
 # æ£€æŸ¥ç­‰å¾…å¯¹å†²çš„æŒä»“
 if symbol in self.waiting_hedges:
 hedge = self.waiting_hedges[symbol]
 self._check_hedge_entry(hedge, price, timestamp)

 # æ£€æŸ¥å·²å¯¹å†²çš„æŒä»“
 if symbol in self.active_hedges:
 hedge = self.active_hedges[symbol]
 self._check_hedge_exit(hedge, price, timestamp)

 def _open_first_leg(self, hedge: HedgePosition, price: float,
 position_usdt: float, leverage: int) -> bool:
 """å¼€ç¬¬ä¸€è…¿"""
 try:
 # è®¡ç®—æ•°é‡
 quantity = (position_usdt * leverage) / price

 # è·å–äº¤æ˜“å¯¹ç²¾åº¦
 precision = self._get_quantity_precision(hedge.symbol)
 quantity = round(quantity, precision)

 # è®¾ç½®æ æ†
 self.client.set_leverage(hedge.symbol, leverage)

 # å¸‚ä»·å•å¼€ä»“
 order = self.client.place_order(
 symbol=hedge.symbol,
 side="SELL" if hedge.first_leg_side == "SHORT" else "BUY",
 order_type="MARKET",
 quantity=quantity,
 reduce_only=False
 )

 if order:
 hedge.first_leg_order_id = order.get('orderId', '')
 hedge.first_leg_quantity = quantity
 hedge.first_leg_entry_price = float(order.get('avgPrice', price))
 hedge.first_leg_filled = True
 hedge.first_leg_time = get_beijing_time()
 hedge.state = HedgeState.FIRST_LEG_OPEN
 return True

 except Exception as e:
 print(f"å¼€ä»“é”™è¯¯: {e}")

 return False

 def _open_second_leg(self, hedge: HedgePosition, price: float) -> bool:
 """å¼€ç¬¬äºŒè…¿ï¼ˆå¯¹å†²è…¿ï¼‰"""
 try:
 # ä½¿ç”¨ç›¸åŒæ•°é‡
 quantity = hedge.first_leg_quantity

 # å¸‚ä»·å•å¼€ä»“
 order = self.client.place_order(
 symbol=hedge.symbol,
 side="BUY" if hedge.second_leg_side == "LONG" else "SELL",
 order_type="MARKET",
 quantity=quantity,
 reduce_only=False
 )

 if order:
 hedge.second_leg_order_id = order.get('orderId', '')
 hedge.second_leg_quantity = quantity
 hedge.second_leg_entry_price = float(order.get('avgPrice', price))
 hedge.second_leg_filled = True
 hedge.second_leg_time = get_beijing_time()
 hedge.state = HedgeState.HEDGED

 # è®¡ç®—å¹³ä»“ç›®æ ‡
 self._calculate_exit_targets(hedge)

 return True

 except Exception as e:
 print(f"å¯¹å†²å¼€ä»“é”™è¯¯: {e}")

 return False

 def _calculate_hedge_targets(self, hedge: HedgePosition, signal: PinSignal):
 """è®¡ç®—å¯¹å†²ç›®æ ‡ä»·æ ¼"""
 entry = hedge.first_leg_entry_price if hedge.first_leg_entry_price > 0 else signal.entry_price

 if signal.direction == "UP":
 # ä¸Šæ’é’ˆåšç©ºåï¼Œç­‰ä»·æ ¼è¿›ä¸€æ­¥å›è°ƒå†åšå¤š
 # ç›®æ ‡ï¼šå›è°ƒåˆ°æ’é’ˆå¹…åº¦çš„50%ä½ç½®
 target_retracement = HEDGE_CONFIG["hedge_retracement_percent"] / 100
 hedge.hedge_target_price = signal.peak_price - (signal.peak_price - signal.start_price) * target_retracement
 else:
 # ä¸‹æ’é’ˆåšå¤šåï¼Œç­‰ä»·æ ¼åå¼¹å†åšç©º
 target_retracement = HEDGE_CONFIG["hedge_retracement_percent"] / 100
 hedge.hedge_target_price = signal.peak_price + (signal.start_price - signal.peak_price) * target_retracement

 def _calculate_exit_targets(self, hedge: HedgePosition):
 """è®¡ç®—å¹³ä»“ç›®æ ‡ï¼ˆå¯¹å†²åï¼‰"""
 # å¯¹å†²åï¼Œæˆ‘ä»¬å¸Œæœ›ä¸¤è¾¹éƒ½èƒ½ç›ˆåˆ©å¹³ä»“
 # ç¬¬ä¸€è…¿åœ¨å³°å€¼æ–¹å‘ç›ˆåˆ©ï¼Œç¬¬äºŒè…¿åœ¨å›è°ƒæ–¹å‘ç›ˆåˆ©

 first_entry = hedge.first_leg_entry_price
 second_entry = hedge.second_leg_entry_price

 # ç®€åŒ–ï¼šå–ä¸¤ä¸ªå…¥åœºä»·çš„ä¸­é—´ä½œä¸ºç›®æ ‡
 mid_price = (first_entry + second_entry) / 2

 tp_percent = HEDGE_CONFIG["take_profit_after_hedge"] / 100
 sl_percent = HEDGE_CONFIG["stop_loss_after_hedge"] / 100

 if hedge.first_leg_side == "SHORT":
 # ç¬¬ä¸€è…¿ç©ºï¼Œç¬¬äºŒè…¿å¤š
 # å¸Œæœ›ä»·æ ¼åœ¨ä¸­é—´åä¸‹å¹³ä»“ï¼ˆç©ºå•ç›ˆåˆ©æ›´å¤šï¼‰
 hedge.take_profit_price = mid_price * (1 - tp_percent)
 hedge.stop_loss_price = second_entry * (1 + sl_percent)
 else:
 # ç¬¬ä¸€è…¿å¤šï¼Œç¬¬äºŒè…¿ç©º
 hedge.take_profit_price = mid_price * (1 + tp_percent)
 hedge.stop_loss_price = second_entry * (1 - sl_percent)

 def _check_hedge_entry(self, hedge: HedgePosition, price: float, timestamp: datetime):
 """æ£€æŸ¥æ˜¯å¦åº”è¯¥å¼€å¯¹å†²è…¿"""
 if hedge.state != HedgeState.FIRST_LEG_OPEN:
 return

 # æ£€æŸ¥è¶…æ—¶
 elapsed = (timestamp - hedge.first_leg_time).total_seconds()
 if elapsed > HEDGE_CONFIG["hedge_wait_timeout_seconds"]:
 print(f"\nâ° [{format_time()}] å¯¹å†²ç­‰å¾…è¶…æ—¶: {hedge.symbol}")
 self._close_first_leg_only(hedge, price, "timeout")
 return

 # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¯¹å†²ç›®æ ‡
 should_hedge = False

 if hedge.signal.direction == "UP":
 # ä¸Šæ’é’ˆåšç©ºï¼Œç­‰ä»·æ ¼ä¸‹è·Œåˆ°ç›®æ ‡
 if price <= hedge.hedge_target_price:
 should_hedge = True
 else:
 # ä¸‹æ’é’ˆåšå¤šï¼Œç­‰ä»·æ ¼ä¸Šæ¶¨åˆ°ç›®æ ‡
 if price >= hedge.hedge_target_price:
 should_hedge = True

 if should_hedge:
 print(f"\nğŸ¯ [{format_time()}] è¾¾åˆ°å¯¹å†²ç›®æ ‡: {hedge.symbol}")
 print(f" ç›®æ ‡ä»·: {hedge.hedge_target_price:.6f}")
 print(f" å½“å‰ä»·: {price:.6f}")

 # å¼€å¯¹å†²è…¿
 success = self._open_second_leg(hedge, price)

 if success:
 # ç§»åŠ¨åˆ°æ´»è·ƒå¯¹å†²
 del self.waiting_hedges[hedge.symbol]
 self.active_hedges[hedge.symbol] = hedge

 print(f"\nâœ… [{format_time()}] å¯¹å†²å®Œæˆ!")
 print(f" ç¬¬ä¸€è…¿: {hedge.first_leg_side} @ {hedge.first_leg_entry_price:.6f}")
 print(f" ç¬¬äºŒè…¿: {hedge.second_leg_side} @ {hedge.second_leg_entry_price:.6f}")
 print(f" æ­¢ç›ˆä»·: {hedge.take_profit_price:.6f}")
 print(f" æ­¢æŸä»·: {hedge.stop_loss_price:.6f}")

 def _check_hedge_exit(self, hedge: HedgePosition, price: float, timestamp: datetime):
 """æ£€æŸ¥æ˜¯å¦åº”è¯¥å¹³ä»“"""
 if hedge.state != HedgeState.HEDGED:
 return

 should_close = False
 reason = ""

 if hedge.first_leg_side == "SHORT":
 # ç¬¬ä¸€è…¿ç©ºï¼Œç¬¬äºŒè…¿å¤š
 if price <= hedge.take_profit_price:
 should_close = True
 reason = "take_profit"
 elif price >= hedge.stop_loss_price:
 should_close = True
 reason = "stop_loss"
 else:
 # ç¬¬ä¸€è…¿å¤šï¼Œç¬¬äºŒè…¿ç©º
 if price >= hedge.take_profit_price:
 should_close = True
 reason = "take_profit"
 elif price <= hedge.stop_loss_price:
 should_close = True
 reason = "stop_loss"

 if should_close:
 print(f"\nğŸ“¤ [{format_time()}] è§¦å‘å¹³ä»“: {hedge.symbol} ({reason})")
 self._close_hedge(hedge, price, reason)

 def _close_first_leg_only(self, hedge: HedgePosition, price: float, reason: str):
 """åªå¹³ç¬¬ä¸€è…¿ï¼ˆæœªå¯¹å†²çš„æƒ…å†µï¼‰"""
 try:
 order = self.client.place_order(
 symbol=hedge.symbol,
 side="BUY" if hedge.first_leg_side == "SHORT" else "SELL",
 order_type="MARKET",
 quantity=hedge.first_leg_quantity,
 reduce_only=True
 )

 if order:
 exit_price = float(order.get('avgPrice', price))

 # è®¡ç®—ç›ˆäº
 if hedge.first_leg_side == "SHORT":
 pnl_percent = (hedge.first_leg_entry_price - exit_price) / hedge.first_leg_entry_price
 else:
 pnl_percent = (exit_price - hedge.first_leg_entry_price) / hedge.first_leg_entry_price

 hedge.first_leg_pnl = self.config.POSITION_USDT * pnl_percent * self.config.LEVERAGE
 hedge.total_pnl = hedge.first_leg_pnl
 hedge.close_reason = reason
 hedge.closed_at = get_beijing_time()
 hedge.state = HedgeState.NONE

 # ç§»å‡ºç­‰å¾…åˆ—è¡¨
 if hedge.symbol in self.waiting_hedges:
 del self.waiting_hedges[hedge.symbol]

 self.completed_hedges.append(hedge)
 self._update_stats(hedge)

 print(f" å¹³ä»“ç›ˆäº: {hedge.total_pnl:+.4f} USDT")

 except Exception as e:
 print(f"å¹³ä»“é”™è¯¯: {e}")

 def _close_hedge(self, hedge: HedgePosition, price: float, reason: str):
 """å¹³æ‰å¯¹å†²æŒä»“

 é¡ºåºï¼šå…ˆå¹³ç¬¬ä¸€è…¿ï¼ˆé€šå¸¸æ˜¯ç›ˆåˆ©è…¿ï¼‰ï¼Œå†å¹³ç¬¬äºŒè…¿
 """
 hedge.state = HedgeState.CLOSING

 try:
 #

---
## ğŸ§‘â€ğŸ’» User

è¾“å‡ºä¸­æ–­äº†ï¼Œè¯·ä½ è¡¥å……

---
## ğŸ¤– Assistant

å¥½çš„ï¼Œæˆ‘ç»§ç»­è¡¥å……å®Œæ•´çš„ä»£ç ï¼š

```python
    def _close_hedge(self, hedge: HedgePosition, price: float, reason: str):
        """å¹³æ‰å¯¹å†²æŒä»“
        
        é¡ºåºï¼šå…ˆå¹³ç¬¬ä¸€è…¿ï¼ˆé€šå¸¸æ˜¯ç›ˆåˆ©è…¿ï¼‰ï¼Œå†å¹³ç¬¬äºŒè…¿
        """
        hedge.state = HedgeState.CLOSING
        
        try:
            # æ ¹æ®é…ç½®å†³å®šå¹³ä»“é¡ºåº
            if HEDGE_CONFIG["close_order"] == "SHORT_FIRST":
                # å…ˆå¹³ç©ºå•
                if hedge.first_leg_side == "SHORT":
                    first_to_close = "first"
                else:
                    first_to_close = "second"
            else:
                # å…ˆå¹³ç¬¬ä¸€è…¿
                first_to_close = "first"
            
            # å¹³ç¬¬ä¸€ä¸ª
            if first_to_close == "first":
                exit_price_1 = self._close_leg(hedge, "first", price)
                exit_price_2 = self._close_leg(hedge, "second", price)
            else:
                exit_price_2 = self._close_leg(hedge, "second", price)
                exit_price_1 = self._close_leg(hedge, "first", price)
            
            # è®¡ç®—ç›ˆäº
            self._calculate_pnl(hedge, exit_price_1, exit_price_2)
            
            hedge.close_reason = reason
            hedge.closed_at = get_beijing_time()
            hedge.state = HedgeState.NONE
            
            # ç§»å‡ºæ´»è·ƒåˆ—è¡¨
            if hedge.symbol in self.active_hedges:
                del self.active_hedges[hedge.symbol]
            
            self.completed_hedges.append(hedge)
            self._update_stats(hedge)
            
            # æ‰“å°ç»“æœ
            pnl_color = "\033[92m" if hedge.total_pnl > 0 else "\033[91m"
            reset = "\033[0m"
            
            print(f"\n{'='*60}")
            print(f"å¯¹å†²å¹³ä»“å®Œæˆ: {hedge.symbol}")
            print(f"   ç¬¬ä¸€è…¿ç›ˆäº: {hedge.first_leg_pnl:+.4f} USDT")
            print(f"   ç¬¬äºŒè…¿ç›ˆäº: {hedge.second_leg_pnl:+.4f} USDT")
            print(f"   æ€»ç›ˆäº: {pnl_color}{hedge.total_pnl:+.4f} USDT{reset}")
            print(f"   å¹³ä»“åŸå› : {reason}")
            print(f"{'='*60}")
            
        except Exception as e:
            print(f"å¯¹å†²å¹³ä»“é”™è¯¯: {e}")
    
    def _close_leg(self, hedge: HedgePosition, leg: str, current_price: float) -> float:
        """å¹³æ‰ä¸€æ¡è…¿
        
        Args:
            hedge: å¯¹å†²æŒä»“
            leg: "first" æˆ– "second"
            current_price: å½“å‰ä»·æ ¼
            
        Returns:
            å®é™…æˆäº¤ä»·æ ¼
        """
        if leg == "first":
            side = hedge.first_leg_side
            quantity = hedge.first_leg_quantity
        else:
            side = hedge.second_leg_side
            quantity = hedge.second_leg_quantity
        
        # å¹³ä»“æ–¹å‘ä¸å¼€ä»“ç›¸å
        close_side = "BUY" if side == "SHORT" else "SELL"
        
        try:
            order = self.client.place_order(
                symbol=hedge.symbol,
                side=close_side,
                order_type="MARKET",
                quantity=quantity,
                reduce_only=True
            )
            
            if order:
                return float(order.get('avgPrice', current_price))
        except Exception as e:
            print(f"å¹³ä»“é”™è¯¯ ({leg}): {e}")
        
        return current_price
    
    def _calculate_pnl(self, hedge: HedgePosition, exit_price_1: float, exit_price_2: float):
        """è®¡ç®—ç›ˆäº"""
        leverage = self.config.LEVERAGE
        position_usdt = self.config.POSITION_USDT
        fee_rate = self.config.FEE_RATE
        
        # ç¬¬ä¸€è…¿ç›ˆäº
        if hedge.first_leg_side == "SHORT":
            pnl_percent_1 = (hedge.first_leg_entry_price - exit_price_1) / hedge.first_leg_entry_price
        else:
            pnl_percent_1 = (exit_price_1 - hedge.first_leg_entry_price) / hedge.first_leg_entry_price
        
        # ç¬¬äºŒè…¿ç›ˆäº
        if hedge.second_leg_side == "SHORT":
            pnl_percent_2 = (hedge.second_leg_entry_price - exit_price_2) / hedge.second_leg_entry_price
        else:
            pnl_percent_2 = (exit_price_2 - hedge.second_leg_entry_price) / hedge.second_leg_entry_price
        
        # è®¡ç®—é‡‘é¢ï¼ˆè€ƒè™‘æ æ†å’Œæ‰‹ç»­è´¹ï¼‰
        fee_per_leg = position_usdt * fee_rate * 2  # å¼€ä»“+å¹³ä»“
        
        hedge.first_leg_pnl = position_usdt * pnl_percent_1 * leverage - fee_per_leg
        hedge.second_leg_pnl = position_usdt * pnl_percent_2 * leverage - fee_per_leg
        hedge.total_pnl = hedge.first_leg_pnl + hedge.second_leg_pnl
    
    def _update_stats(self, hedge: HedgePosition):
        """æ›´æ–°ç»Ÿè®¡"""
        self.total_trades += 1
        self.total_pnl += hedge.total_pnl
        if hedge.total_pnl > 0:
            self.winning_trades += 1
    
    def _get_quantity_precision(self, symbol: str) -> int:
        """è·å–æ•°é‡ç²¾åº¦"""
        # å¸¸è§äº¤æ˜“å¯¹çš„ç²¾åº¦
        precision_map = {
            "BTCUSDT": 3,
            "ETHUSDT": 3,
            "BNBUSDT": 2,
            "SOLUSDT": 1,
            "TRUMPUSDT": 1,
            "AAVEUSDT": 2,
        }
        return precision_map.get(symbol, 3)
    
    def close_all_positions(self, reason: str = "manual"):
        """å¹³æ‰æ‰€æœ‰æŒä»“"""
        with self.lock:
            # å¹³æ‰ç­‰å¾…å¯¹å†²çš„æŒä»“
            for symbol, hedge in list(self.waiting_hedges.items()):
                price = self.client.get_market_price(symbol) or hedge.first_leg_entry_price
                self._close_first_leg_only(hedge, price, reason)
            
            # å¹³æ‰å·²å¯¹å†²çš„æŒä»“
            for symbol, hedge in list(self.active_hedges.items()):
                price = self.client.get_market_price(symbol) or hedge.first_leg_entry_price
                self._close_hedge(hedge, price, reason)
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡"""
        win_rate = (self.winning_trades / self.total_trades * 100) if self.total_trades > 0 else 0
        return {
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "win_rate": win_rate,
            "total_pnl": self.total_pnl,
            "active_hedges": len(self.active_hedges),
            "waiting_hedges": len(self.waiting_hedges),
        }


# ============== é›†æˆè¿è¡Œå™¨ ==============

class HedgeStrategyRunner:
    """å¯¹å†²ç­–ç•¥é›†æˆè¿è¡Œå™¨"""
    
    def __init__(self, config: TestnetConfig = None):
        self.config = config or load_config()
        self.running = False
        
        # åˆå§‹åŒ–äº¤æ˜“å®¢æˆ·ç«¯
        self.client = BinanceFuturesClient(
            api_key=self.config.BINANCE_API_KEY,
            api_secret=self.config.BINANCE_API_SECRET,
            testnet=True,
            timeout=self.config.API_TIMEOUT,
            enable_proxy=self.config.ENABLE_PROXY,
            proxy_url=self.config.PROXY_URL if self.config.ENABLE_PROXY else None
        )
        
        # åˆå§‹åŒ–å¯¹å†²äº¤æ˜“ç®¡ç†å™¨
        self.hedge_manager = HedgeTradeManager(self.client, self.config)
        
        # ç»Ÿè®¡
        self._start_time = None
        self._signals_count = 0
    
    def start(self, symbols: List[str] = None):
        """å¯åŠ¨è¿è¡Œå™¨"""
        symbols = symbols or DEFAULT_SYMBOLS
        
        # æµ‹è¯•è¿æ¥
        print("\nğŸ”— æµ‹è¯•äº¤æ˜“æ‰€è¿æ¥...")
        if not self.client.test_connectivity():
            print("âŒ æ— æ³•è¿æ¥åˆ°å¸å®‰æµ‹è¯•ç½‘")
            return
        
        account = self.client.get_account_info()
        if not account:
            print("âŒ æ— æ³•è·å–è´¦æˆ·ä¿¡æ¯ï¼Œè¯·æ£€æŸ¥APIå¯†é’¥")
            return
        
        print(f"âœ… è¿æ¥æˆåŠŸ")
        print(f"   å¯ç”¨ä½™é¢: {account.available_balance:.2f} USDT")
        
        # è®¾ç½®åŒå‘æŒä»“æ¨¡å¼ï¼ˆHedge Modeï¼‰
        print("\nâš™ï¸ è®¾ç½®åŒå‘æŒä»“æ¨¡å¼...")
        try:
            self.client.set_position_mode(hedge_mode=True)
            print("âœ… åŒå‘æŒä»“æ¨¡å¼å·²å¯ç”¨")
        except Exception as e:
            print(f"âš ï¸ è®¾ç½®æŒä»“æ¨¡å¼: {e}")
            print("   (å¯èƒ½å·²ç»æ˜¯åŒå‘æŒä»“æ¨¡å¼)")
        
        # å¯åŠ¨æ’é’ˆæ£€æµ‹å™¨
        self.detector = PinDetector(symbols)
        self.detector.set_signal_callback(self._on_pin_signal)
        self.detector.set_price_callback(self._on_price_update)
        self.detector.start()
        
        self.running = True
        self._start_time = time.time()
        
        # æ‰“å°é…ç½®
        print("\n" + "=" * 70)
        print("          å¯¹å†²ç­–ç•¥è¿è¡Œå™¨å·²å¯åŠ¨ï¼ˆæµ‹è¯•ç½‘ï¼‰")
        print("=" * 70)
        print(f"ç›‘æ§äº¤æ˜“å¯¹: {', '.join(symbols)}")
        print(f"ä»“ä½å¤§å°: {self.config.POSITION_USDT} USDT")
        print(f"æ æ†: {self.config.LEVERAGE}x")
        print("-" * 70)
        print("å¯¹å†²ç­–ç•¥å‚æ•°:")
        print(f"   å¯¹å†²å›æ’¤: {HEDGE_CONFIG['hedge_retracement_percent']}%")
        print(f"   å¯¹å†²è¶…æ—¶: {HEDGE_CONFIG['hedge_wait_timeout_seconds']}ç§’")
        print(f"   å¹³ä»“é¡ºåº: {HEDGE_CONFIG['close_order']}")
        print(f"   å¯¹å†²åæ­¢ç›ˆ: {HEDGE_CONFIG['take_profit_after_hedge']}%")
        print(f"   å¯¹å†²åæ­¢æŸ: {HEDGE_CONFIG['stop_loss_after_hedge']}%")
        print("=" * 70)
        print("\nğŸ’¡ ç­–ç•¥è¯´æ˜:")
        print("   1. æ£€æµ‹åˆ°ä¸Šæ’é’ˆ â†’ é«˜ä½å¼€ç©º â†’ å›è°ƒåå¼€å¤š â†’ é”å®šåˆ©æ¶¦")
        print("   2. æ£€æµ‹åˆ°ä¸‹æ’é’ˆ â†’ ä½ä½å¼€å¤š â†’ åå¼¹åå¼€ç©º â†’ é”å®šåˆ©æ¶¦")
        print("   3. å¹³ä»“æ—¶å…ˆå¹³ç©ºå•ï¼Œå†å¹³å¤šå•")
        print("=" * 70)
        
        # ä¿¡å·å¤„ç†
        signal.signal(signal.SIGINT, self._signal_handler)
        
        # ä¸»å¾ªç¯
        try:
            last_status_time = 0
            while self.running:
                time.sleep(0.1)
                
                # æ¯30ç§’æ‰“å°çŠ¶æ€
                now = time.time()
                if now - last_status_time >= 30:
                    self._print_status()
                    last_status_time = now
                    
        except KeyboardInterrupt:
            pass
        finally:
            self.stop()
    
    def _on_pin_signal(self, signal: PinSignal):
        """å¤„ç†æ’é’ˆä¿¡å·"""
        self._signals_count += 1
        
        print(f"\n{'='*70}")
        print(f"ğŸ“¡ æ”¶åˆ°ä¿¡å· #{self._signals_count}")
        print(f"   äº¤æ˜“å¯¹: {signal.symbol}")
        print(f"   æ–¹å‘: {signal.direction}")
        print(f"   å¹…åº¦: {signal.amplitude:.2f}%")
        print(f"   å›æ’¤: {signal.retracement:.1f}%")
        print(f"   å…¥åœºä»·: {signal.entry_price:.6f}")
        print(f"{'='*70}")
        
        # æ‰§è¡Œå¯¹å†²ç­–ç•¥
        self.hedge_manager.on_pin_signal(signal)
    
    def _on_price_update(self, symbol: str, price: float, timestamp: datetime):
        """å¤„ç†ä»·æ ¼æ›´æ–°"""
        self.hedge_manager.on_price_update(symbol, price, timestamp)
    
    def _print_status(self):
        """æ‰“å°çŠ¶æ€"""
        if not self.running:
            return
        
        elapsed = time.time() - self._start_time
        stats = self.hedge_manager.get_stats()
        
        print(f"\n{'='*70}")
        print(f"ğŸ“Š è¿è¡ŒçŠ¶æ€ (è¿è¡Œæ—¶é•¿: {elapsed/60:.1f}åˆ†é’Ÿ)")
        print(f"-" * 70)
        print(f"   ä¿¡å·æ•°: {self._signals_count}")
        print(f"   ç­‰å¾…å¯¹å†²: {stats['waiting_hedges']}")
        print(f"   å·²å¯¹å†²: {stats['active_hedges']}")
        print(f"   å·²å®Œæˆ: {stats['total_trades']}")
        
        if stats['total_trades'] > 0:
            pnl_color = "\033[92m" if stats['total_pnl'] > 0 else "\033[91m"
            reset = "\033[0m"
            print(f"   æ€»ç›ˆäº: {pnl_color}{stats['total_pnl']:+.4f} USDT{reset}")
            print(f"   èƒœç‡: {stats['win_rate']:.1f}%")
        
        print(f"   WebSocket: {'ğŸŸ¢ å·²è¿æ¥' if self.detector.is_connected() else 'ğŸ”´ æ–­å¼€'}")
        print(f"{'='*70}")
    
    def stop(self):
        """åœæ­¢"""
        if not self.running:
            return
        
        print("\n\nğŸ›‘ æ­£åœ¨åœæ­¢...")
        self.running = False
        
        # åœæ­¢æ£€æµ‹å™¨
        if hasattr(self, 'detector'):
            self.detector.stop()
        
        # å¹³æ‰æ‰€æœ‰æŒä»“
        stats = self.hedge_manager.get_stats()
        active = stats['waiting_hedges'] + stats['active_hedges']
        if active > 0:
            print(f"ğŸ“¤ å¹³ä»“ {active} ä¸ªæŒä»“...")
            self.hedge_manager.close_all_positions(reason="shutdown")
        
        # æ‰“å°æœ€ç»ˆç»Ÿè®¡
        self._print_final_stats()
    
    def _print_final_stats(self):
        """æ‰“å°æœ€ç»ˆç»Ÿè®¡"""
        stats = self.hedge_manager.get_stats()
        elapsed = time.time() - self._start_time if self._start_time else 0
        
        print("\n" + "=" * 70)
        print("                    æœ€ç»ˆç»Ÿè®¡")
        print("=" * 70)
        print(f"   è¿è¡Œæ—¶é•¿: {elapsed/60:.1f}åˆ†é’Ÿ")
        print(f"   ä¿¡å·æ•°: {self._signals_count}")
        print(f"   å®Œæˆäº¤æ˜“: {stats['total_trades']}")
        
        if stats['total_trades'] > 0:
            pnl_color = "\033[92m" if stats['total_pnl'] > 0 else "\033[91m"
            reset = "\033[0m"
            print(f"   èƒœç‡: {stats['win_rate']:.1f}%")
            print(f"   æ€»ç›ˆäº: {pnl_color}{stats['total_pnl']:+.4f} USDT{reset}")
        
        print("=" * 70)
    
    def _signal_handler(self, signum, frame):
        """ä¿¡å·å¤„ç†å™¨"""
        self.stop()
        sys.exit(0)


# ============== ä¸»å‡½æ•° ==============

def main():
    """ä¸»å‡½æ•°"""
    print("=" * 70)
    print("       Flash Arbitrage Bot - å¯¹å†²ç­–ç•¥ï¼ˆæµ‹è¯•ç½‘ï¼‰")
    print("=" * 70)
    
    # åŠ è½½é…ç½®
    try:
        config = load_config()
    except ValueError as e:
        print(f"\nâŒ é…ç½®é”™è¯¯: {e}")
        print("\nè¯·è®¾ç½®ç¯å¢ƒå˜é‡:")
        print("  export BINANCE_TESTNET_API_KEY=your_api_key")
        print("  export BINANCE_TESTNET_API_SECRET=your_api_secret")
        print("\næˆ–è®¿é—® https://testnet.binancefuture.com/ è·å–æµ‹è¯•ç½‘APIå¯†é’¥")
        return
    
    # åˆ›å»ºè¿è¡Œå™¨
    runner = HedgeStrategyRunner(config)
    
    # å¯åŠ¨
    runner.start(DEFAULT_SYMBOLS)


if __name__ == "__main__":
    main()
```

---

## ä»£ç è¯´æ˜

### æ ¸å¿ƒæ”¹åŠ¨

1. **æ–°å¢ `HedgeState` æšä¸¾**ï¼šè·Ÿè¸ªå¯¹å†²çŠ¶æ€ï¼ˆæ— æŒä»“ â†’ ç¬¬ä¸€è…¿ â†’ å·²å¯¹å†² â†’ å¹³ä»“ä¸­ï¼‰

2. **æ–°å¢ `HedgePosition` æ•°æ®ç±»**ï¼šè®°å½•å®Œæ•´çš„å¯¹å†²æŒä»“ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä¸¤æ¡è…¿çš„å…¥åœºä»·ã€æ•°é‡ã€ç›ˆäºç­‰

3. **æ–°å¢ `HedgeTradeManager` ç±»**ï¼šæ ¸å¿ƒå¯¹å†²äº¤æ˜“ç®¡ç†å™¨
 - `on_pin_signal()`: å¤„ç†æ’é’ˆä¿¡å·ï¼Œå¼€ç¬¬ä¸€è…¿
 - `on_price_update()`: ç›‘æ§ä»·æ ¼ï¼Œå†³å®šå¼€å¯¹å†²è…¿æˆ–å¹³ä»“
 - `_open_first_leg()`: å¼€ç¬¬ä¸€è…¿
 - `_open_second_leg()`: å¼€å¯¹å†²è…¿
 - `_close_hedge()`: æŒ‰é¡ºåºå¹³ä»“ï¼ˆå…ˆå¹³ç©ºåå¹³å¤šï¼‰

4. **å¯¹å†²ç­–ç•¥å‚æ•° `HEDGE_CONFIG`**ï¼š
```python
   HEDGE_CONFIG = {
       "enable_hedge": True,
       "hedge_retracement_percent": 30,      # å›è°ƒ30%æ—¶å¼€å¯¹å†²
       "hedge_wait_timeout_seconds": 60,     # ç­‰å¾…å¯¹å†²è¶…æ—¶
       "close_order": "SHORT_FIRST",         # å…ˆå¹³ç©ºå•
       "take_profit_after_hedge": 0.5,       # å¯¹å†²åæ­¢ç›ˆ
       "stop_loss_after_hedge": 1.0,         # å¯¹å†²åæ­¢æŸ
   }
   ```

### ç­–ç•¥æµç¨‹

```
ä¸Šæ’é’ˆæ£€æµ‹åˆ° (ä»·æ ¼ä»3.60æ¶¨åˆ°3.68åˆè·Œå›3.64)
 â”‚
 â–¼
å¼€ç©ºå• @ 3.64 (ç¬¬ä¸€è…¿)
 â”‚
 â–¼ (ç­‰å¾…ä»·æ ¼ç»§ç»­ä¸‹è·Œ)
 â”‚
ä»·æ ¼è·Œåˆ° ~3.62 (å›è°ƒ30%)
 â”‚
 â–¼
å¼€å¤šå• @ 3.62 (ç¬¬äºŒè…¿/å¯¹å†²è…¿)
 â”‚
 â–¼ (å½¢æˆåŒå‘æŒä»“)
 â”‚
ç›‘æ§ä»·æ ¼ï¼Œè§¦å‘æ­¢ç›ˆ/æ­¢æŸ
 â”‚
 â–¼
å…ˆå¹³ç©ºå•ï¼Œå†å¹³å¤šå•
```

### æ³¨æ„äº‹é¡¹

1. **åŒå‘æŒä»“æ¨¡å¼**ï¼šä»£ç ä¼šå°è¯•è®¾ç½® `hedge_mode=True`ï¼Œè¿™éœ€è¦äº¤æ˜“æ‰€æ”¯æŒ

2. **å¦‚æœäº¤æ˜“æ‰€ä¸æ”¯æŒåŒå‘æŒä»“**ï¼šå¯èƒ½éœ€è¦ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„åˆçº¦æˆ–è°ƒæ•´ç­–ç•¥

3. **æµ‹è¯•ç½‘é™åˆ¶**ï¼šå¸å®‰æµ‹è¯•ç½‘å¯èƒ½å¯¹æŸäº›äº¤æ˜“å¯¹æœ‰é™åˆ¶ï¼Œå»ºè®®å…ˆç”¨æ”¯æŒçš„äº¤æ˜“å¯¹æµ‹è¯•

éœ€è¦æˆ‘è¿›ä¸€æ­¥è§£é‡Šæˆ–è°ƒæ•´ä»»ä½•éƒ¨åˆ†å—ï¼Ÿ

---
## ğŸ§‘â€ğŸ’» User

å‘ä¸Šæ’é’ˆå’Œå‘ä¸‹æ’é’ˆåº”è¯¥è¦æœ‰å¯¹åº”çš„å¤„ç†é€»è¾‘ï¼Œç›‘æµ‹çš„å®æ—¶ä»·æ ¼è¦åŒæ—¶ä½œç”¨äºåŒä¸€å¸ç§çš„ä¸¤å•ï¼Œå¾€å¾€åƒæ’é’ˆå›è°ƒé‚£ä¸€å•è¦å…ˆå¹³ï¼Œåç»­é¡ºåº”æ’é’ˆæ–¹å‘çš„å•å¯ä»¥æŒç»­æŒæœ‰ä¸€æ®µæ—¶é—´ï¼Œå¦‚æœä»·æ ¼é¡ºåº”è¶‹åŠ¿æ¶¨è·Œï¼Œå¯ä»¥è®¾ç«‹æ›´é«˜çš„æ­¢ç›ˆï¼ŒåŒæ—¶åŠ¨æ€è®¾ç«‹æ­¢æŸä¸ºæ’é’ˆé¡¶éƒ¨ï¼Œè¿™æ ·å³ä¾¿åç»­å›è°ƒåˆ°æ’é’ˆå¤„ï¼Œä¹Ÿèƒ½ç¡®ä¿åˆ©æ¶¦é”æ­»ã€‚å¦å¤–ä¸éœ€è¦å°†ä»“ä½åˆ†æ‰¹æ­¢æŸæ­¢ç›ˆï¼Œå°èµ„é‡‘æƒ…å†µä¸‹ç›´æ¥å…¨ä»“æ“ä½œã€‚

---
## ğŸ¤– Assistant

æˆ‘ç†è§£äº†ï¼è®©æˆ‘é‡æ–°æ¢³ç†ç­–ç•¥é€»è¾‘å¹¶é‡å†™ä»£ç ï¼š

## ç­–ç•¥æ ¸å¿ƒé€»è¾‘

**ä¸Šæ’é’ˆæƒ…å†µï¼š**
1. ä»·æ ¼æ€¥æ¶¨åˆ°é«˜ç‚¹ï¼ˆæ’é’ˆé¡¶éƒ¨ï¼‰â†’ ç«‹å³å¼€ç©º
2. ä»·æ ¼å›è°ƒ â†’ ç«‹å³å¼€å¤šï¼ˆé”å®šç©ºå•åˆ©æ¶¦ï¼‰
3. **å…ˆå¹³å¤šå•**ï¼ˆåƒå›è°ƒçš„å•ï¼Œå¿«é€Ÿæ­¢ç›ˆï¼‰
4. **ç©ºå•ç»§ç»­æŒæœ‰**ï¼Œå› ä¸ºæ’é’ˆåå¾€å¾€ç»§ç»­ä¸‹è·Œ
5. ç©ºå•æ­¢æŸè®¾åœ¨æ’é’ˆé¡¶éƒ¨ï¼Œæ­¢ç›ˆå¯ä»¥è®¾æ›´é«˜

**ä¸‹æ’é’ˆæƒ…å†µï¼š**
1. ä»·æ ¼æ€¥è·Œåˆ°ä½ç‚¹ï¼ˆæ’é’ˆåº•éƒ¨ï¼‰â†’ ç«‹å³å¼€å¤š
2. ä»·æ ¼åå¼¹ â†’ ç«‹å³å¼€ç©ºï¼ˆé”å®šå¤šå•åˆ©æ¶¦ï¼‰
3. **å…ˆå¹³ç©ºå•**ï¼ˆåƒåå¼¹çš„å•ï¼Œå¿«é€Ÿæ­¢ç›ˆï¼‰
4. **å¤šå•ç»§ç»­æŒæœ‰**ï¼Œå› ä¸ºæ’é’ˆåå¾€å¾€ç»§ç»­ä¸Šæ¶¨
5. å¤šå•æ­¢æŸè®¾åœ¨æ’é’ˆåº•éƒ¨ï¼Œæ­¢ç›ˆå¯ä»¥è®¾æ›´é«˜

```python
#!/usr/bin/env python3
"""
æµ‹è¯•ç½‘äº¤æ˜“ä¸æ’é’ˆæ£€æµ‹å™¨é›†æˆ - åŒå‘å¯¹å†²ç­–ç•¥ç‰ˆæœ¬

ç­–ç•¥é€»è¾‘:
ã€ä¸Šæ’é’ˆã€‘
1. ä»·æ ¼æ€¥æ¶¨åˆ°é«˜ç‚¹ â†’ å¼€ç©ºï¼ˆé¡ºåº”å›è°ƒæ–¹å‘ï¼‰
2. ä»·æ ¼å›è°ƒ â†’ å¼€å¤šï¼ˆé”å®šç©ºå•åˆ©æ¶¦ï¼‰
3. å…ˆå¹³å¤šå•ï¼ˆåƒå›è°ƒåˆ©æ¶¦ï¼‰
4. ç©ºå•ç»§ç»­æŒæœ‰ï¼ˆé¡ºåº”æ’é’ˆåè¶‹åŠ¿ï¼‰ï¼Œæ­¢æŸè®¾åœ¨æ’é’ˆé¡¶éƒ¨

ã€ä¸‹æ’é’ˆã€‘
1. ä»·æ ¼æ€¥è·Œåˆ°ä½ç‚¹ â†’ å¼€å¤šï¼ˆé¡ºåº”åå¼¹æ–¹å‘ï¼‰
2. ä»·æ ¼åå¼¹ â†’ å¼€ç©ºï¼ˆé”å®šå¤šå•åˆ©æ¶¦ï¼‰
3. å…ˆå¹³ç©ºå•ï¼ˆåƒåå¼¹åˆ©æ¶¦ï¼‰
4. å¤šå•ç»§ç»­æŒæœ‰ï¼ˆé¡ºåº”æ’é’ˆåè¶‹åŠ¿ï¼‰ï¼Œæ­¢æŸè®¾åœ¨æ’é’ˆåº•éƒ¨

ä½¿ç”¨æ–¹æ³•:
python testnet_with_recorder.py
"""

import os
import sys
import time
import signal
import json
import threading
import websocket
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass, field
from enum import Enum

# æ·»åŠ è·¯å¾„
script_dir = Path(__file__).parent.resolve()
sys.path.insert(0, str(script_dir / "src"))
sys.path.insert(0, str(script_dir))

# å¯¼å…¥äº¤æ˜“ç»„ä»¶
from src.exchange.binance_futures import BinanceFuturesClient
from config.testnet_config import load_config, TestnetConfig


# ============== é…ç½® ==============

PROXY_HOST = "127.0.0.1"
PROXY_HTTP_PORT = 7897
USE_PROXY = True

BEIJING_TZ = timezone(timedelta(hours=8))

def get_beijing_time() -> datetime:
 return datetime.now(BEIJING_TZ)

def format_time(dt: datetime = None) -> str:
 if dt is None:
 dt = get_beijing_time()
 return dt.strftime("%H:%M:%S.%f")[:-3]

# WebSocketç«¯ç‚¹
WS_ENDPOINT = "wss://stream.binancefuture.com/ws"

# ç›‘æ§äº¤æ˜“å¯¹
DEFAULT_SYMBOLS = [
 "BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT", "TRUMPUSDT",
 "AAVEUSDT", "XRPUSDT", "DOGEUSDT"
]

# æ’é’ˆæ£€æµ‹å‚æ•°
SPIKE_CONFIG = {
 "price_window_ms": 1000,
 "min_spike_percent": 0.3,
 "max_spike_percent": 5.0,
 "initial_retracement_percent": 15, # åˆå§‹å›æ’¤è§¦å‘å¼€ä»“
}

# äº¤æ˜“ç­–ç•¥å‚æ•°
STRATEGY_CONFIG = {
 # å¯¹å†²è…¿å‚æ•°ï¼ˆåƒå›è°ƒçš„å•ï¼‰
 "hedge_retracement_trigger": 30, # å›æ’¤30%æ—¶å¼€å¯¹å†²è…¿
 "hedge_take_profit_percent": 1.0, # å¯¹å†²è…¿æ­¢ç›ˆ1%ï¼ˆå¿«é€Ÿè·åˆ©ï¼‰
 "hedge_wait_timeout": 30, # ç­‰å¾…å¯¹å†²æœ€å¤§æ—¶é—´ï¼ˆç§’ï¼‰

 # è¶‹åŠ¿è…¿å‚æ•°ï¼ˆé¡ºåº”è¶‹åŠ¿çš„å•ï¼‰
 "trend_initial_tp_percent": 2.0, # è¶‹åŠ¿è…¿åˆå§‹æ­¢ç›ˆ2%
 "trend_extended_tp_percent": 5.0, # è¶‹åŠ¿å»¶ç»­æ—¶æ­¢ç›ˆæé«˜åˆ°5%
 "trend_trailing_stop_percent": 0.5, # è·Ÿè¸ªæ­¢æŸå›è°ƒ0.5%
 "trend_max_hold_seconds": 300, # è¶‹åŠ¿è…¿æœ€å¤§æŒæœ‰5åˆ†é’Ÿ

 # é£æ§
 "stop_loss_at_spike_peak": True, # æ­¢æŸè®¾åœ¨æ’é’ˆé¡¶/åº•éƒ¨
 "max_concurrent_trades": 3, # æœ€å¤§åŒæ—¶æŒä»“æ•°
}


# ============== æ•°æ®ç±» ==============

class TradeState(Enum):
 """äº¤æ˜“çŠ¶æ€"""
 WAITING_HEDGE = "waiting_hedge" # ç¬¬ä¸€è…¿å·²å¼€ï¼Œç­‰å¾…å¯¹å†²
 HEDGED = "hedged" # å·²å¯¹å†²
 HEDGE_CLOSED = "hedge_closed" # å¯¹å†²è…¿å·²å¹³ï¼Œè¶‹åŠ¿è…¿ç»§ç»­
 FULLY_CLOSED = "fully_closed" # å…¨éƒ¨å¹³ä»“


@dataclass
class PinSignal:
 """æ’é’ˆä¿¡å·"""
 symbol: str
 direction: str # UPï¼ˆä¸Šæ’é’ˆï¼‰/ DOWNï¼ˆä¸‹æ’é’ˆï¼‰
 start_price: float # æ’é’ˆèµ·å§‹ä»·
 peak_price: float # æ’é’ˆé¡¶/åº•éƒ¨ä»·æ ¼
 current_price: float # æ£€æµ‹æ—¶ä»·æ ¼
 amplitude: float # å¹…åº¦ç™¾åˆ†æ¯”
 retracement: float # å›æ’¤ç™¾åˆ†æ¯”
 detected_at: datetime = None

 def __post_init__(self):
 if self.detected_at is None:
 self.detected_at = get_beijing_time()

 @property
 def signal_id(self) -> str:
 return f"{self.symbol}_{int(self.detected_at.timestamp())}"


@dataclass
class TradePair:
 """äº¤æ˜“å¯¹ï¼ˆåŒ…å«è¶‹åŠ¿è…¿å’Œå¯¹å†²è…¿ï¼‰"""
 symbol: str
 signal: PinSignal
 state: TradeState = TradeState.WAITING_HEDGE
 created_at: datetime = None

 # è¶‹åŠ¿è…¿ï¼ˆé¡ºåº”æ’é’ˆåè¶‹åŠ¿ï¼‰
 # ä¸Šæ’é’ˆååšç©ºï¼Œä¸‹æ’é’ˆååšå¤š
 trend_side: str = "" # LONG / SHORT
 trend_entry_price: float = 0.0
 trend_quantity: float = 0.0
 trend_order_id: str = ""
 trend_stop_loss: float = 0.0 # æ­¢æŸä»·ï¼ˆæ’é’ˆé¡¶/åº•éƒ¨ï¼‰
 trend_take_profit: float = 0.0 # æ­¢ç›ˆä»·
 trend_highest_profit: float = 0.0 # æœ€é«˜æµ®ç›ˆï¼ˆç”¨äºè·Ÿè¸ªæ­¢æŸï¼‰
 trend_pnl: float = 0.0
 trend_closed: bool = False
 trend_close_price: float = 0.0

 # å¯¹å†²è…¿ï¼ˆåƒå›è°ƒåˆ©æ¶¦ï¼‰
 # ä¸Šæ’é’ˆååšå¤šåƒå›è°ƒï¼Œä¸‹æ’é’ˆååšç©ºåƒåå¼¹
 hedge_side: str = "" # LONG / SHORT
 hedge_entry_price: float = 0.0
 hedge_quantity: float = 0.0
 hedge_order_id: str = ""
 hedge_take_profit: float = 0.0
 hedge_pnl: float = 0.0
 hedge_closed: bool = False
 hedge_close_price: float = 0.0

 # ç›®æ ‡ä»·æ ¼
 hedge_trigger_price: float = 0.0 # è§¦å‘å¼€å¯¹å†²è…¿çš„ä»·æ ¼

 # æ€»ç›ˆäº
 total_pnl: float = 0.0
 close_reason: str = ""
 closed_at: datetime = None

 def __post_init__(self):
 if self.created_at is None:
 self.created_at = get_beijing_time()

 # æ ¹æ®æ’é’ˆæ–¹å‘ç¡®å®šäº¤æ˜“æ–¹å‘
 if self.signal.direction == "UP":
 # ä¸Šæ’é’ˆï¼šè¶‹åŠ¿è…¿åšç©ºï¼ˆé¢„æœŸç»§ç»­è·Œï¼‰ï¼Œå¯¹å†²è…¿åšå¤šï¼ˆåƒå›è°ƒï¼‰
 self.trend_side = "SHORT"
 self.hedge_side = "LONG"
 else:
 # ä¸‹æ’é’ˆï¼šè¶‹åŠ¿è…¿åšå¤šï¼ˆé¢„æœŸç»§ç»­æ¶¨ï¼‰ï¼Œå¯¹å†²è…¿åšç©ºï¼ˆåƒåå¼¹ï¼‰
 self.trend_side = "LONG"
 self.hedge_side = "SHORT"


# ============== æ’é’ˆæ£€æµ‹å™¨ ==============

class PinDetector:
 """æ’é’ˆæ£€æµ‹å™¨"""

 def __init__(self, symbols: List[str]):
 self.symbols = [s.lower() for s in symbols]
 self.symbols_upper = [s.upper() for s in symbols]
 self.running = False
 self.ws_connected = False
 self.ws = None
 self.message_count = 0

 # ç›‘æ§æ•°æ®
 self.monitors: Dict[str, Dict] = {
 s: {
 "current_price": 0.0,
 "window_start_ms": 0,
 "window_start_price": 0.0,
 "window_high": 0.0,
 "window_low": float('inf'),
 "last_signal_time": 0,
 }
 for s in self.symbols_upper
 }

 # å›è°ƒ
 self.on_signal_callback = None
 self.on_price_callback = None

 def set_callbacks(self, on_signal=None, on_price=None):
 self.on_signal_callback = on_signal
 self.on_price_callback = on_price

 def get_price(self, symbol: str) -> float:
 return self.monitors.get(symbol, {}).get("current_price", 0.0)

 def start(self):
 self.running = True
 self._connect()

 def stop(self):
 self.running = False
 if self.ws:
 self.ws.close()

 def _connect(self):
 streams = [f"{s}@aggTrade" for s in self.symbols]
 ws_url = f"{WS_ENDPOINT}/{'/'.join(streams)}"

 print(f"[{format_time()}] è¿æ¥WebSocket: {len(self.symbols)}ä¸ªäº¤æ˜“å¯¹")

 self.ws = websocket.WebSocketApp(
 ws_url,
 on_message=self._on_message,
 on_error=self._on_error,
 on_close=self._on_close,
 on_open=self._on_open
 )

 def run():
 if USE_PROXY:
 self.ws.run_forever(
 http_proxy_host=PROXY_HOST,
 http_proxy_port=PROXY_HTTP_PORT,
 proxy_type="http"
 )
 else:
 self.ws.run_forever()

 threading.Thread(target=run, daemon=True).start()

 def _on_open(self, ws):
 self.ws_connected = True
 print(f"[{format_time()}] âœ… WebSocketå·²è¿æ¥")

 def _on_error(self, ws, error):
 if error:
 print(f"[{format_time()}] WSé”™è¯¯: {str(error)[:50]}")

 def _on_close(self, ws, code, msg):
 self.ws_connected = False
 if self.running:
 time.sleep(2)
 self._connect()

 def _on_message(self, ws, message):
 try:
 self.message_count += 1
 data = json.loads(message)
 symbol = data.get('s', '').upper()

 if symbol not in self.monitors:
 return

 price = float(data['p'])
 timestamp = datetime.fromtimestamp(data['T'] / 1000, tz=BEIJING_TZ)

 self._process_price(symbol, price, timestamp)
 except:
 pass

 def _process_price(self, symbol: str, price: float, timestamp: datetime):
 m = self.monitors[symbol]
 now_ms = timestamp.timestamp() * 1000

 m["current_price"] = price

 # ä»·æ ¼å›è°ƒ
 if self.on_price_callback:
 self.on_price_callback(symbol, price, timestamp)

 # åˆå§‹åŒ–çª—å£
 if m["window_start_ms"] == 0:
 m["window_start_ms"] = now_ms
 m["window_start_price"] = price
 m["window_high"] = price
 m["window_low"] = price
 return

 # æ›´æ–°é«˜ä½ç‚¹
 m["window_high"] = max(m["window_high"], price)
 m["window_low"] = min(m["window_low"], price)

 # æ£€æµ‹çª—å£
 window_ms = now_ms - m["window_start_ms"]
 if window_ms >= SPIKE_CONFIG["price_window_ms"]:
 self._detect_spike(symbol, price, timestamp, m, now_ms)

 # é‡ç½®çª—å£
 m["window_start_ms"] = now_ms
 m["window_start_price"] = price
 m["window_high"] = price
 m["window_low"] = price

 def _detect_spike(self, symbol: str, price: float, timestamp: datetime, m: Dict, now_ms: float):
 start = m["window_start_price"]
 high = m["window_high"]
 low = m["window_low"]

 if start == 0:
 return

 # å†·å´æœŸ5ç§’
 if now_ms - m["last_signal_time"] < 5000:
 return

 min_amp = SPIKE_CONFIG["min_spike_percent"]
 max_amp = SPIKE_CONFIG["max_spike_percent"]
 ret_threshold = SPIKE_CONFIG["initial_retracement_percent"]

 signal = None

 # ä¸Šæ’é’ˆï¼šä»·æ ¼å†²é«˜åå›è½
 if high > start:
 up_amp = (high - start) / start * 100
 if min_amp <= up_amp <= max_amp:
 ret = (high - price) / (high - start) * 100
 if ret >= ret_threshold:
 signal = PinSignal(
 symbol=symbol,
 direction="UP",
 start_price=start,
 peak_price=high,
 current_price=price,
 amplitude=up_amp,
 retracement=ret,
 detected_at=timestamp
 )

 # ä¸‹æ’é’ˆï¼šä»·æ ¼ä¸‹æ¢ååå¼¹
 if signal is None and start > low:
 down_amp = (start - low) / start * 100
 if min_amp <= down_amp <= max_amp:
 ret = (price - low) / (start - low) * 100
 if ret >= ret_threshold:
 signal = PinSignal(
 symbol=symbol,
 direction="DOWN",
 start_price=start,
 peak_price=low,
 current_price=price,
 amplitude=down_amp,
 retracement=ret,
 detected_at=timestamp
 )

 if signal:
 m["last_signal_time"] = now_ms
 if self.on_signal_callback:
 self.on_signal_callback(signal)


# ============== äº¤æ˜“ç®¡ç†å™¨ ==============

class TradeManager:
 """äº¤æ˜“ç®¡ç†å™¨ - å®ç°åŒå‘å¯¹å†²ç­–ç•¥"""

 def __init__(self, client: BinanceFuturesClient, config: TestnetConfig):
 self.client = client
 self.config = config
 self.lock = threading.Lock()

 # æ´»è·ƒäº¤æ˜“
 self.active_trades: Dict[str, TradePair] = {}

 # å·²å®Œæˆäº¤æ˜“
 self.completed_trades: List[TradePair] = []

 # ç»Ÿè®¡
 self.stats = {
 "total_signals": 0,
 "total_trades": 0,
 "winning_trades": 0,
 "total_pnl": 0.0,
 }

 def on_signal(self, signal: PinSignal) -> bool:
 """å¤„ç†æ’é’ˆä¿¡å·"""
 with self.lock:
 self.stats["total_signals"] += 1

 # æ£€æŸ¥æ˜¯å¦å·²æœ‰è¯¥äº¤æ˜“å¯¹çš„æŒä»“
 if signal.symbol in self.active_trades:
 print(f"[{format_time()}] {signal.symbol} å·²æœ‰æŒä»“ï¼Œè·³è¿‡")
 return False

 # æ£€æŸ¥æœ€å¤§æŒä»“æ•°
 if len(self.active_trades) >= STRATEGY_CONFIG["max_concurrent_trades"]:
 print(f"[{format_time()}] å·²è¾¾æœ€å¤§æŒä»“æ•°ï¼Œè·³è¿‡")
 return False

 # åˆ›å»ºäº¤æ˜“å¯¹
 trade = TradePair(symbol=signal.symbol, signal=signal)

 # å¼€è¶‹åŠ¿è…¿
 success = self._open_trend_leg(trade)

 if success:
 # è®¡ç®—å¯¹å†²è§¦å‘ä»·å’Œæ­¢æŸæ­¢ç›ˆ
 self._calculate_targets(trade)

 with self.lock:
 self.active_trades[signal.symbol] = trade

 self._print_trade_opened(trade)
 return True

 return False

 def on_price_update(self, symbol: str, price: float, timestamp: datetime):
 """å¤„ç†ä»·æ ¼æ›´æ–°"""
 with self.lock:
 if symbol not in self.active_trades:
 return
 trade = self.active_trades[symbol]

 # æ ¹æ®çŠ¶æ€å¤„ç†
 if trade.state == TradeState.WAITING_HEDGE:
 self._check_hedge_trigger(trade, price, timestamp)

 elif trade.state == TradeState.HEDGED:
 self._check_hedge_exit(trade, price)
 self._check_trend_trailing(trade, price)

 elif trade.state == TradeState.HEDGE_CLOSED:
 self._check_trend_exit(trade, price)

 def _open_trend_leg(self, trade: TradePair) -> bool:
 """å¼€è¶‹åŠ¿è…¿"""
 try:
 signal = trade.signal
 price = signal.current_price

 # è®¡ç®—æ•°é‡
 quantity = self._calculate_quantity(trade.symbol, price)

 # è®¾ç½®æ æ†
 self.client.set_leverage(trade.symbol, self.config.LEVERAGE)

 # å¼€ä»“
 side = "SELL" if trade.trend_side == "SHORT" else "BUY"
 order = self.client.place_order(
 symbol=trade.symbol,
 side=side,
 order_type="MARKET",
 quantity=quantity,
 reduce_only=False
 )

 if order:
 trade.trend_order_id = str(order.get('orderId', ''))
 trade.trend_quantity = quantity
 trade.trend_entry_price = float(order.get('avgPrice', 0)) or price
 trade.state = TradeState.WAITING_HEDGE
 return True

 except Exception as e:
 print(f"[{format_time()}] å¼€ä»“é”™è¯¯: {e}")

 return False

 def _open_hedge_leg(self, trade: TradePair, price: float) -> bool:
 """å¼€å¯¹å†²è…¿"""
 try:
 # ä½¿ç”¨ç›¸åŒæ•°é‡
 quantity = trade.trend_quantity

 side = "BUY" if trade.hedge_side == "LONG" else "SELL"
 order = self.client.place_order(
 symbol=trade.symbol,
 side=side,
 order_type="MARKET",
 quantity=quantity,
 reduce_only=False
 )

 if order:
 trade.hedge_order_id = str(order.get('orderId', ''))
 trade.hedge_quantity = quantity
 trade.hedge_entry_price = float(order.get('avgPrice', 0)) or price
 trade.state = TradeState.HEDGED

 # è®¡ç®—å¯¹å†²è…¿æ­¢ç›ˆ
 tp_percent = STRATEGY_CONFIG["hedge_take_profit_percent"] / 100
 if trade.hedge_side == "LONG":
 trade.hedge_take_profit = trade.hedge_entry_price * (1 + tp_percent / self.config.LEVERAGE)
 else:
 trade.hedge_take_profit = trade.hedge_entry_price * (1 - tp_percent / self.config.LEVERAGE)

 return True

 except Exception as e:
 print(f"[{format_time()}] å¯¹å†²å¼€ä»“é”™è¯¯: {e}")

 return False

 def _calculate_targets(self, trade: TradePair):
 """è®¡ç®—ç›®æ ‡ä»·æ ¼"""
 signal = trade.signal

 # è¶‹åŠ¿è…¿æ­¢æŸï¼šè®¾åœ¨æ’é’ˆé¡¶/åº•éƒ¨
 if STRATEGY_CONFIG["stop_loss_at_spike_peak"]:
 if trade.trend_side == "SHORT":
 # åšç©ºï¼Œæ­¢æŸåœ¨æ’é’ˆé¡¶éƒ¨ä¸Šæ–¹
 trade.trend_stop_loss = signal.peak_price * 1.002 # ä¸Šæ–¹0.2%
 else:
 # åšå¤šï¼Œæ­¢æŸåœ¨æ’é’ˆåº•éƒ¨ä¸‹æ–¹
 trade.trend_stop_loss = signal.peak_price * 0.998 # ä¸‹æ–¹0.2%

 # è¶‹åŠ¿è…¿åˆå§‹æ­¢ç›ˆ
 tp_percent = STRATEGY_CONFIG["trend_initial_tp_percent"] / 100
 if trade.trend_side == "SHORT":
 trade.trend_take_profit = trade.trend_entry_price * (1 - tp_percent / self.config.LEVERAGE)
 else:
 trade.trend_take_profit = trade.trend_entry_price * (1 + tp_percent / self.config.LEVERAGE)

 # å¯¹å†²è…¿è§¦å‘ä»·æ ¼ï¼ˆå›æ’¤ä¸€å®šæ¯”ä¾‹æ—¶å¼€å¯¹å†²ï¼‰
 ret_trigger = STRATEGY_CONFIG["hedge_retracement_trigger"] / 100
 if signal.direction == "UP":
 # ä¸Šæ’é’ˆï¼Œç­‰ä»·æ ¼ç»§ç»­ä¸‹è·Œ
 trade.hedge_trigger_price = signal.peak_price - (signal.peak_price - signal.start_price) * ret_trigger
 else:
 # ä¸‹æ’é’ˆï¼Œç­‰ä»·æ ¼ç»§ç»­ä¸Šæ¶¨
 trade.hedge_trigger_price = signal.peak_price + (signal.start_price - signal.peak_price) * ret_trigger

 def _check_hedge_trigger(self, trade: TradePair, price: float, timestamp: datetime):
 """æ£€æŸ¥æ˜¯å¦è§¦å‘å¼€å¯¹å†²è…¿"""
 # æ£€æŸ¥è¶…æ—¶
 elapsed = (timestamp - trade.created_at).total_seconds()
 if elapsed > STRATEGY_CONFIG["hedge_wait_timeout"]:
 print(f"\nâ° [{format_time()}] {trade.symbol} å¯¹å†²ç­‰å¾…è¶…æ—¶ï¼Œç›´æ¥ç®¡ç†è¶‹åŠ¿è…¿")
 trade.state = TradeState.HEDGE_CLOSED
 return

 # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¯¹å†²è§¦å‘ä»·
 should_hedge = False
 if trade.signal.direction == "UP":
 # ä¸Šæ’é’ˆåšç©ºï¼Œç­‰ä»·æ ¼è·Œåˆ°è§¦å‘ä»·
 if price <= trade.hedge_trigger_price:
 should_hedge = True
 else:
 # ä¸‹æ’é’ˆåšå¤šï¼Œç­‰ä»·æ ¼æ¶¨åˆ°è§¦å‘ä»·
 if price >= trade.hedge_trigger_price:
 should_hedge = True

 # æ£€æŸ¥è¶‹åŠ¿è…¿æ­¢æŸ
 if trade.trend_side == "SHORT" and price >= trade.trend_stop_loss:
 self._close_all(trade, price, "trend_stop_loss")
 return
 elif trade.trend_side == "LONG" and price <= trade.trend_stop_loss:
 self._close_all(trade, price, "trend_stop_loss")
 return

 if should_hedge:
 print(f"\nğŸ¯ [{format_time()}] {trade.symbol} è§¦å‘å¯¹å†² @ {price:.6f}")
 success = self._open_hedge_leg(trade, price)
 if success:
 self._print_hedge_opened(trade)

 def _check_hedge_exit(self, trade: TradePair, price: float):
 """æ£€æŸ¥å¯¹å†²è…¿æ˜¯å¦åº”è¯¥å¹³ä»“"""
 if trade.hedge_closed:
 return

 should_close = False

 # å¯¹å†²è…¿æ­¢ç›ˆ
 if trade.hedge_side == "LONG" and price >= trade.hedge_take_profit:
 should_close = True
 elif trade.hedge_side == "SHORT" and price <= trade.hedge_take_profit:
 should_close = True

 if should_close:
 self._close_hedge_leg(trade, price, "take_profit")

 def _check_trend_trailing(self, trade: TradePair, price: float):
 """æ£€æŸ¥è¶‹åŠ¿è…¿è·Ÿè¸ªæ­¢æŸ"""
 if trade.trend_closed:
 return

 # è®¡ç®—å½“å‰æµ®ç›ˆ
 if trade.trend_side == "SHORT":
 profit_percent = (trade.trend_entry_price - price) / trade.trend_entry_price * 100 * self.config.LEVERAGE
 else:
 profit_percent = (price - trade.trend_entry_price) / trade.trend_entry_price * 100 * self.config.LEVERAGE

 # æ›´æ–°æœ€é«˜æµ®ç›ˆ
 if profit_percent > trade.trend_highest_profit:
 trade.trend_highest_profit = profit_percent

 # å¦‚æœç›ˆåˆ©è¶…è¿‡åˆå§‹æ­¢ç›ˆï¼Œæé«˜æ­¢ç›ˆç›®æ ‡
 if profit_percent >= STRATEGY_CONFIG["trend_initial_tp_percent"]:
 new_tp_percent = STRATEGY_CONFIG["trend_extended_tp_percent"] / 100
 if trade.trend_side == "SHORT":
 trade.trend_take_profit = trade.trend_entry_price * (1 - new_tp_percent / self.config.LEVERAGE)
 else:
 trade.trend_take_profit = trade.trend_entry_price * (1 + new_tp_percent / self.config.LEVERAGE)

 # è·Ÿè¸ªæ­¢æŸï¼šä»æœ€é«˜ç›ˆåˆ©å›æ’¤ä¸€å®šæ¯”ä¾‹å°±å¹³ä»“
 trailing_percent = STRATEGY_CONFIG["trend_trailing_stop_percent"]
 if trade.trend_highest_profit > trailing_percent:
 if trade.trend_highest_profit - profit_percent >= trailing_percent:
 self._close_trend_leg(trade, price, "trailing_stop")

 def _check_trend_exit(self, trade: TradePair, price: float):
 """æ£€æŸ¥è¶‹åŠ¿è…¿é€€å‡ºï¼ˆå¯¹å†²è…¿å·²å¹³çš„æƒ…å†µï¼‰"""
 if trade.trend_closed:
 return

 # æ­¢æŸæ£€æŸ¥
 if trade.trend_side == "SHORT" and price >= trade.trend_stop_loss:
 self._close_trend_leg(trade, price, "stop_loss")
 return
 elif trade.trend_side == "LONG" and price <= trade.trend_stop_loss:
 self._close_trend_leg(trade, price, "stop_loss")
 return

 # æ­¢ç›ˆæ£€æŸ¥
 if trade.trend_side == "SHORT" and price <= trade.trend_take_profit:
 self._close_trend_leg(trade, price, "take_profit")
 return
 elif trade.trend_side == "LONG" and price >= trade.trend_take_profit:
 self._close_trend_leg(trade, price, "take_profit")
 return

 # è®¡ç®—æµ®ç›ˆå¹¶æ›´æ–°è·Ÿè¸ªæ­¢æŸ
 self._check_trend_trailing(trade, price)

 # è¶…æ—¶æ£€æŸ¥
 elapsed = (get_beijing_time() - trade.created_at).total_seconds()
 if elapsed > STRATEGY_CONFIG["trend_max_hold_seconds"]:
 self._close_trend_leg(trade, price, "timeout")

 def _close_hedge_leg(self, trade: TradePair, price: float, reason: str):
 """å¹³å¯¹å†²è…¿"""
 try:
 side = "SELL" if trade.hedge_side == "LONG" else "BUY"
 order = self.client.place_order(
 symbol=trade.symbol,
 side=side,
 order_type="MARKET",
 quantity=trade.hedge_quantity,
 reduce_only=True
 )

 if order:
 exit_price = float(order.get('avgPrice', 0)) or price
 trade.hedge_close_price = exit_price
 trade.hedge_closed = True

 # è®¡ç®—ç›ˆäº
 if trade.hedge_side == "LONG":
 pnl_percent = (exit_price - trade.hedge_entry_price) / trade.hedge_entry_price
 else:
 pnl_percent = (trade.hedge_entry_price - exit_price) / trade.hedge_entry_price

 trade.hedge_pnl = self.config.POSITION_USDT * pnl_percent * self.config.LEVERAGE
 trade.hedge_pnl -= self.config.POSITION_USDT * self.config.FEE_RATE * 2 # æ‰‹ç»­è´¹

 trade.state = TradeState.HEDGE_CLOSED

 print(f"\nğŸ“¤ [{format_time()}] {trade.symbol} å¯¹å†²è…¿å¹³ä»“ ({reason})")
 print(f" å…¥åœº: {trade.hedge_entry_price:.6f} â†’ å‡ºåœº: {exit_price:.6f}")
 print(f" ç›ˆäº: {trade.hedge_pnl:+.4f} USDT")

 except Exception as e:
 print(f"å¹³ä»“é”™è¯¯: {e}")

 def _close_trend_leg(self, trade: TradePair, price: float, reason: str):
 """å¹³è¶‹åŠ¿è…¿"""
 try:
 side = "BUY" if trade.trend_side == "SHORT" else "SELL"
 order = self.client.place_order(
 symbol=trade.symbol,
 side=side,
 order_type="MARKET",
 quantity=trade.trend_quantity,

---
## ğŸ§‘â€ğŸ’» User

è¾“å‡ºä¸­æ–­äº†ï¼Œè¯·ä½ è¡¥å……ï¼Œå¦å¤–ä½ çš„ç†è§£æœ‰è¯¯ï¼š

ä¸Šæ’é’ˆæƒ…å†µï¼š
æ ¹æ®å¤§è¶‹åŠ¿åˆ¤æ–­æ­¤æ—¶æ¶¨è·Œè¶‹åŠ¿
è‹¥æ­¤æ—¶ä¸ºä¸Šæ¶¨è¶‹åŠ¿å‘ä¸Šæ’é’ˆ
ä»·æ ¼æ€¥æ¶¨åˆ°é«˜ç‚¹ï¼ˆæ’é’ˆé¡¶éƒ¨ï¼‰â†’ ç«‹å³å¼€ç©º
ä»·æ ¼å›è°ƒä¸€å®šæ°´å¹³ â†’ ç«‹å³å¼€å¤š
æ ¹æ®æ’é’ˆæ°´å¹³ä¼°ç®—ç©ºå•å›è°ƒç»“æŸä»·æ ¼
è¾¾åˆ°ä»·æ ¼é™„è¿‘ï¼Œå…ˆå¹³ç©ºå•ï¼ˆåƒå›è°ƒçš„å•ï¼Œå¿«é€Ÿæ­¢ç›ˆï¼‰
å¤šå•ç»§ç»­æŒæœ‰ï¼Œå› ä¸ºæ’é’ˆåå¾€å¾€é¡ºè¶‹åŠ¿æ¶¨è·Œ
å¤šå•æ­¢æŸè®¾åœ¨æ’é’ˆé¡¶éƒ¨ï¼Œæ­¢ç›ˆå¯ä»¥è®¾æ›´é«˜
è‹¥æ­¤æ—¶ä¸ºä¸‹è·Œè¶‹åŠ¿å‘ä¸Šæ’é’ˆåˆ™åªåœ¨æ’é’ˆé¡¶ç‚¹æ“ä½œ

ä¸‹æ’é’ˆæƒ…å†µåŒç†

---
## ğŸ¤– Assistant

æˆ‘ç†è§£äº†ï¼è®©æˆ‘é‡æ–°æ¢³ç†ç­–ç•¥é€»è¾‘ï¼š

## æ­£ç¡®çš„ç­–ç•¥é€»è¾‘

**ä¸Šæ’é’ˆ + ä¸Šæ¶¨è¶‹åŠ¿ï¼š**
1. ä»·æ ¼æ€¥æ¶¨åˆ°é«˜ç‚¹ï¼ˆæ’é’ˆé¡¶éƒ¨ï¼‰â†’ ç«‹å³å¼€ç©ºï¼ˆåƒå›è°ƒï¼‰
2. ä»·æ ¼å›è°ƒä¸€å®šæ°´å¹³ â†’ ç«‹å³å¼€å¤šï¼ˆé¡ºè¶‹åŠ¿ï¼‰
3. ä¼°ç®—å›è°ƒç»“æŸä½ç½® â†’ **å…ˆå¹³ç©ºå•**ï¼ˆå¿«é€Ÿæ­¢ç›ˆï¼‰
4. **å¤šå•ç»§ç»­æŒæœ‰**ï¼ˆé¡ºåº”ä¸Šæ¶¨è¶‹åŠ¿ï¼‰
5. å¤šå•æ­¢æŸè®¾åœ¨æ’é’ˆé¡¶éƒ¨ï¼Œæ­¢ç›ˆè®¾æ›´é«˜

**ä¸Šæ’é’ˆ + ä¸‹è·Œè¶‹åŠ¿ï¼š**
- åªåœ¨æ’é’ˆé¡¶ç‚¹å¼€ç©ºï¼Œä¸å¼€å¯¹å†²å¤šå•

**ä¸‹æ’é’ˆ + ä¸‹è·Œè¶‹åŠ¿ï¼š**
1. ä»·æ ¼æ€¥è·Œåˆ°ä½ç‚¹ï¼ˆæ’é’ˆåº•éƒ¨ï¼‰â†’ ç«‹å³å¼€å¤šï¼ˆåƒåå¼¹ï¼‰
2. ä»·æ ¼åå¼¹ä¸€å®šæ°´å¹³ â†’ ç«‹å³å¼€ç©ºï¼ˆé¡ºè¶‹åŠ¿ï¼‰
3. ä¼°ç®—åå¼¹ç»“æŸä½ç½® â†’ **å…ˆå¹³å¤šå•**ï¼ˆå¿«é€Ÿæ­¢ç›ˆï¼‰
4. **ç©ºå•ç»§ç»­æŒæœ‰**ï¼ˆé¡ºåº”ä¸‹è·Œè¶‹åŠ¿ï¼‰
5. ç©ºå•æ­¢æŸè®¾åœ¨æ’é’ˆåº•éƒ¨ï¼Œæ­¢ç›ˆè®¾æ›´ä½

**ä¸‹æ’é’ˆ + ä¸Šæ¶¨è¶‹åŠ¿ï¼š**
- åªåœ¨æ’é’ˆåº•ç‚¹å¼€å¤šï¼Œä¸å¼€å¯¹å†²ç©ºå•

```python
#!/usr/bin/env python3
"""
æµ‹è¯•ç½‘äº¤æ˜“ä¸æ’é’ˆæ£€æµ‹å™¨é›†æˆ - åŒå‘å¯¹å†²ç­–ç•¥ç‰ˆæœ¬

ç­–ç•¥é€»è¾‘:
ã€ä¸Šæ’é’ˆ + ä¸Šæ¶¨è¶‹åŠ¿ã€‘
1. æ’é’ˆé¡¶éƒ¨ â†’ å¼€ç©ºï¼ˆåƒå›è°ƒï¼‰
2. å›è°ƒä¸€å®šæ°´å¹³ â†’ å¼€å¤šï¼ˆé¡ºè¶‹åŠ¿ï¼‰
3. å›è°ƒç»“æŸ â†’ å…ˆå¹³ç©ºå•
4. å¤šå•ç»§ç»­æŒæœ‰ï¼Œæ­¢æŸåœ¨æ’é’ˆé¡¶éƒ¨

ã€ä¸Šæ’é’ˆ + ä¸‹è·Œè¶‹åŠ¿ã€‘
- åªåœ¨æ’é’ˆé¡¶ç‚¹å¼€ç©º

ã€ä¸‹æ’é’ˆ + ä¸‹è·Œè¶‹åŠ¿ã€‘
1. æ’é’ˆåº•éƒ¨ â†’ å¼€å¤šï¼ˆåƒåå¼¹ï¼‰
2. åå¼¹ä¸€å®šæ°´å¹³ â†’ å¼€ç©ºï¼ˆé¡ºè¶‹åŠ¿ï¼‰
3. åå¼¹ç»“æŸ â†’ å…ˆå¹³å¤šå•
4. ç©ºå•ç»§ç»­æŒæœ‰ï¼Œæ­¢æŸåœ¨æ’é’ˆåº•éƒ¨

ã€ä¸‹æ’é’ˆ + ä¸Šæ¶¨è¶‹åŠ¿ã€‘
- åªåœ¨æ’é’ˆåº•ç‚¹å¼€å¤š
"""

import os
import sys
import time
import signal
import json
import threading
import websocket
import requests
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Deque
from dataclasses import dataclass, field
from collections import deque
from enum import Enum

# æ·»åŠ è·¯å¾„
script_dir = Path(__file__).parent.resolve()
sys.path.insert(0, str(script_dir / "src"))
sys.path.insert(0, str(script_dir))

# å¯¼å…¥äº¤æ˜“ç»„ä»¶
from src.exchange.binance_futures import BinanceFuturesClient
from config.testnet_config import load_config, TestnetConfig


# ============== é…ç½® ==============

PROXY_HOST = "127.0.0.1"
PROXY_HTTP_PORT = 7897
USE_PROXY = True

HTTP_PROXY = {
 'http': f'http://{PROXY_HOST}:{PROXY_HTTP_PORT}',
 'https': f'http://{PROXY_HOST}:{PROXY_HTTP_PORT}',
} if USE_PROXY else {}

BEIJING_TZ = timezone(timedelta(hours=8))

def get_beijing_time() -> datetime:
 return datetime.now(BEIJING_TZ)

def format_time(dt: datetime = None) -> str:
 if dt is None:
 dt = get_beijing_time()
 return dt.strftime("%H:%M:%S.%f")[:-3]

# WebSocketç«¯ç‚¹
WS_ENDPOINT = "wss://stream.binancefuture.com/ws"

# ç›‘æ§äº¤æ˜“å¯¹
DEFAULT_SYMBOLS = [
 "BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT", "TRUMPUSDT",
 "AAVEUSDT", "XRPUSDT", "DOGEUSDT"
]

# æ’é’ˆæ£€æµ‹å‚æ•°
SPIKE_CONFIG = {
 "price_window_ms": 1000,
 "min_spike_percent": 0.3,
 "max_spike_percent": 5.0,
 "initial_retracement_percent": 15,
}

# è¶‹åŠ¿åˆ¤æ–­å‚æ•°
TREND_CONFIG = {
 "ma_period": 20, # MAå‘¨æœŸï¼ˆç”¨äºåˆ¤æ–­è¶‹åŠ¿ï¼‰
 "trend_threshold_percent": 0.1, # è¶‹åŠ¿åˆ¤æ–­é˜ˆå€¼
 "price_history_size": 100, # ä»·æ ¼å†å²å¤§å°
}

# äº¤æ˜“ç­–ç•¥å‚æ•°
STRATEGY_CONFIG = {
 # å›è°ƒè…¿å‚æ•°ï¼ˆåƒå›è°ƒ/åå¼¹çš„å•ï¼‰
 "retracement_open_percent": 30, # å›è°ƒ30%æ—¶å¼€å¯¹å†²è…¿
 "retracement_close_percent": 60, # å›è°ƒ60%æ—¶å¹³å›è°ƒè…¿
 "retracement_timeout_seconds": 30, # å›è°ƒè…¿æœ€å¤§ç­‰å¾…æ—¶é—´

 # è¶‹åŠ¿è…¿å‚æ•°ï¼ˆé¡ºè¶‹åŠ¿çš„å•ï¼‰
 "trend_initial_tp_percent": 2.0, # åˆå§‹æ­¢ç›ˆ2%
 "trend_extended_tp_percent": 5.0, # å»¶ä¼¸æ­¢ç›ˆ5%
 "trend_trailing_callback": 0.5, # è·Ÿè¸ªæ­¢æŸå›è°ƒ0.5%
 "trend_max_hold_seconds": 300, # æœ€å¤§æŒæœ‰5åˆ†é’Ÿ

 # å•è¾¹æ¨¡å¼ï¼ˆæ— å¯¹å†²æ—¶ï¼‰
 "single_leg_tp_percent": 1.5, # å•è¾¹æ­¢ç›ˆ1.5%
 "single_leg_sl_percent": 1.0, # å•è¾¹æ­¢æŸ1.0%

 # é£æ§
 "stop_loss_buffer_percent": 0.2, # æ­¢æŸç¼“å†²0.2%
 "max_concurrent_trades": 3,
}


# ============== æ•°æ®ç±» ==============

class Trend(Enum):
 """è¶‹åŠ¿æ–¹å‘"""
 UP = "up"
 DOWN = "down"
 NEUTRAL = "neutral"


class TradeMode(Enum):
 """äº¤æ˜“æ¨¡å¼"""
 HEDGE = "hedge" # å¯¹å†²æ¨¡å¼ï¼ˆåŒè…¿ï¼‰
 SINGLE = "single" # å•è¾¹æ¨¡å¼ï¼ˆä»…ä¸€è…¿ï¼‰


class TradeState(Enum):
 """äº¤æ˜“çŠ¶æ€"""
 RETRACEMENT_OPEN = "retracement_open" # å›è°ƒè…¿å·²å¼€ï¼Œç­‰å¾…å¼€è¶‹åŠ¿è…¿
 BOTH_OPEN = "both_open" # åŒè…¿éƒ½å¼€
 RETRACEMENT_CLOSED = "retracement_closed" # å›è°ƒè…¿å·²å¹³ï¼Œè¶‹åŠ¿è…¿ç»§ç»­
 SINGLE_OPEN = "single_open" # å•è¾¹æ¨¡å¼ï¼Œä¸€è…¿å¼€ä»“
 CLOSED = "closed" # å…¨éƒ¨å¹³ä»“


@dataclass
class PinSignal:
 """æ’é’ˆä¿¡å·"""
 symbol: str
 direction: str # UPï¼ˆä¸Šæ’é’ˆï¼‰/ DOWNï¼ˆä¸‹æ’é’ˆï¼‰
 start_price: float # æ’é’ˆèµ·å§‹ä»·
 peak_price: float # æ’é’ˆé¡¶/åº•éƒ¨ä»·æ ¼
 current_price: float # æ£€æµ‹æ—¶ä»·æ ¼ï¼ˆå·²å›æ’¤ä¸€å®šæ¯”ä¾‹ï¼‰
 amplitude: float # å¹…åº¦ç™¾åˆ†æ¯”
 retracement: float # å½“å‰å›æ’¤ç™¾åˆ†æ¯”
 trend: Trend # å½“å‰è¶‹åŠ¿
 detected_at: datetime = None

 def __post_init__(self):
 if self.detected_at is None:
 self.detected_at = get_beijing_time()

 @property
 def signal_id(self) -> str:
 return f"{self.symbol}_{int(self.detected_at.timestamp())}"

 def __str__(self):
 icon = "ğŸ”º" if self.direction == "UP" else "ğŸ”»"
 trend_icon = "ğŸ“ˆ" if self.trend == Trend.UP else "ğŸ“‰" if self.trend == Trend.DOWN else "â¡ï¸"
 return f"{self.symbol} {icon} å¹…åº¦:{self.amplitude:.2f}% è¶‹åŠ¿:{trend_icon}"


@dataclass
class TradePair:
 """äº¤æ˜“å¯¹"""
 symbol: str
 signal: PinSignal
 mode: TradeMode # äº¤æ˜“æ¨¡å¼
 state: TradeState = None
 created_at: datetime = None

 # ===== å›è°ƒè…¿ï¼ˆåƒå›è°ƒ/åå¼¹ï¼‰=====
 # ä¸Šæ’é’ˆæ—¶ï¼šå¼€ç©ºåƒå›è°ƒ
 # ä¸‹æ’é’ˆæ—¶ï¼šå¼€å¤šåƒåå¼¹
 retracement_side: str = "" # LONG / SHORT
 retracement_entry_price: float = 0.0
 retracement_quantity: float = 0.0
 retracement_target_close: float = 0.0 # å¹³ä»“ç›®æ ‡ä»·
 retracement_pnl: float = 0.0
 retracement_closed: bool = False

 # ===== è¶‹åŠ¿è…¿ï¼ˆé¡ºè¶‹åŠ¿ï¼‰=====
 # ä¸Šæ¶¨è¶‹åŠ¿ä¸Šæ’é’ˆï¼šå›è°ƒåå¼€å¤š
 # ä¸‹è·Œè¶‹åŠ¿ä¸‹æ’é’ˆï¼šåå¼¹åå¼€ç©º
 trend_side: str = "" # LONG / SHORT
 trend_entry_price: float = 0.0
 trend_quantity: float = 0.0
 trend_stop_loss: float = 0.0 # æ­¢æŸï¼ˆæ’é’ˆé¡¶/åº•éƒ¨ï¼‰
 trend_take_profit: float = 0.0 # æ­¢ç›ˆ
 trend_highest_profit: float = 0.0 # æœ€é«˜æµ®ç›ˆ%
 trend_pnl: float = 0.0
 trend_closed: bool = False

 # ç›®æ ‡ä»·æ ¼
 trend_open_trigger: float = 0.0 # å¼€è¶‹åŠ¿è…¿è§¦å‘ä»·

 # æ€»è®¡
 total_pnl: float = 0.0
 close_reason: str = ""
 closed_at: datetime = None

 def __post_init__(self):
 if self.created_at is None:
 self.created_at = get_beijing_time()

 signal = self.signal

 # æ ¹æ®æ’é’ˆæ–¹å‘å’Œè¶‹åŠ¿ç¡®å®šäº¤æ˜“æ¨¡å¼å’Œæ–¹å‘
 if signal.direction == "UP":
 # ä¸Šæ’é’ˆï¼šå›è°ƒè…¿åšç©º
 self.retracement_side = "SHORT"

 if signal.trend == Trend.UP:
 # ä¸Šæ¶¨è¶‹åŠ¿ï¼šå¯¹å†²æ¨¡å¼ï¼Œè¶‹åŠ¿è…¿åšå¤š
 self.mode = TradeMode.HEDGE
 self.trend_side = "LONG"
 self.state = TradeState.RETRACEMENT_OPEN
 else:
 # ä¸‹è·Œ/ä¸­æ€§è¶‹åŠ¿ï¼šå•è¾¹æ¨¡å¼ï¼Œåªåšç©º
 self.mode = TradeMode.SINGLE
 self.trend_side = ""
 self.state = TradeState.SINGLE_OPEN
 else:
 # ä¸‹æ’é’ˆï¼šå›è°ƒè…¿åšå¤š
 self.retracement_side = "LONG"

 if signal.trend == Trend.DOWN:
 # ä¸‹è·Œè¶‹åŠ¿ï¼šå¯¹å†²æ¨¡å¼ï¼Œè¶‹åŠ¿è…¿åšç©º
 self.mode = TradeMode.HEDGE
 self.trend_side = "SHORT"
 self.state = TradeState.RETRACEMENT_OPEN
 else:
 # ä¸Šæ¶¨/ä¸­æ€§è¶‹åŠ¿ï¼šå•è¾¹æ¨¡å¼ï¼Œåªåšå¤š
 self.mode = TradeMode.SINGLE
 self.trend_side = ""
 self.state = TradeState.SINGLE_OPEN


# ============== è¶‹åŠ¿åˆ†æå™¨ ==============

class TrendAnalyzer:
 """è¶‹åŠ¿åˆ†æå™¨"""

 def __init__(self):
 self.price_history: Dict[str, Deque[float]] = {}
 self.ma_values: Dict[str, float] = {}

 def update_price(self, symbol: str, price: float):
 """æ›´æ–°ä»·æ ¼"""
 if symbol not in self.price_history:
 self.price_history[symbol] = deque(maxlen=TREND_CONFIG["price_history_size"])

 self.price_history[symbol].append(price)

 # è®¡ç®—MA
 if len(self.price_history[symbol]) >= TREND_CONFIG["ma_period"]:
 prices = list(self.price_history[symbol])[-TREND_CONFIG["ma_period"]:]
 self.ma_values[symbol] = sum(prices) / len(prices)

 def get_trend(self, symbol: str, current_price: float) -> Trend:
 """è·å–è¶‹åŠ¿æ–¹å‘"""
 if symbol not in self.ma_values:
 return Trend.NEUTRAL

 ma = self.ma_values[symbol]
 threshold = TREND_CONFIG["trend_threshold_percent"] / 100

 diff = (current_price - ma) / ma

 if diff > threshold:
 return Trend.UP
 elif diff < -threshold:
 return Trend.DOWN
 else:
 return Trend.NEUTRAL

 def get_ma(self, symbol: str) -> float:
 return self.ma_values.get(symbol, 0.0)


# ============== æ’é’ˆæ£€æµ‹å™¨ ==============

class PinDetector:
 """æ’é’ˆæ£€æµ‹å™¨"""

 def __init__(self, symbols: List[str], trend_analyzer: TrendAnalyzer):
 self.symbols = [s.lower() for s in symbols]
 self.symbols_upper = [s.upper() for s in symbols]
 self.trend_analyzer = trend_analyzer
 self.running = False
 self.ws_connected = False
 self.ws = None
 self.message_count = 0

 # ç›‘æ§æ•°æ®
 self.monitors: Dict[str, Dict] = {
 s: {
 "current_price": 0.0,
 "window_start_ms": 0,
 "window_start_price": 0.0,
 "window_high": 0.0,
 "window_low": float('inf'),
 "last_signal_time": 0,
 }
 for s in self.symbols_upper
 }

 # å›è°ƒ
 self.on_signal_callback = None
 self.on_price_callback = None

 def set_callbacks(self, on_signal=None, on_price=None):
 self.on_signal_callback = on_signal
 self.on_price_callback = on_price

 def get_price(self, symbol: str) -> float:
 return self.monitors.get(symbol, {}).get("current_price", 0.0)

 def start(self):
 self.running = True
 self._connect()

 def stop(self):
 self.running = False
 if self.ws:
 self.ws.close()

 def _connect(self):
 streams = [f"{s}@aggTrade" for s in self.symbols]
 ws_url = f"{WS_ENDPOINT}/{'/'.join(streams)}"

 print(f"[{format_time()}] è¿æ¥WebSocket...")

 self.ws = websocket.WebSocketApp(
 ws_url,
 on_message=self._on_message,
 on_error=self._on_error,
 on_close=self._on_close,
 on_open=self._on_open
 )

 def run():
 if USE_PROXY:
 self.ws.run_forever(
 http_proxy_host=PROXY_HOST,
 http_proxy_port=PROXY_HTTP_PORT,
 proxy_type="http"
 )
 else:
 self.ws.run_forever()

 threading.Thread(target=run, daemon=True).start()

 def _on_open(self, ws):
 self.ws_connected = True
 print(f"[{format_time()}] âœ… WebSocketå·²è¿æ¥")

 def _on_error(self, ws, error):
 if error:
 print(f"[{format_time()}] WSé”™è¯¯: {str(error)[:50]}")

 def _on_close(self, ws, code, msg):
 self.ws_connected = False
 if self.running:
 time.sleep(2)
 self._connect()

 def _on_message(self, ws, message):
 try:
 self.message_count += 1
 data = json.loads(message)
 symbol = data.get('s', '').upper()

 if symbol not in self.monitors:
 return

 price = float(data['p'])
 timestamp = datetime.fromtimestamp(data['T'] / 1000, tz=BEIJING_TZ)

 # æ›´æ–°è¶‹åŠ¿åˆ†æå™¨
 self.trend_analyzer.update_price(symbol, price)

 self._process_price(symbol, price, timestamp)
 except:
 pass

 def _process_price(self, symbol: str, price: float, timestamp: datetime):
 m = self.monitors[symbol]
 now_ms = timestamp.timestamp() * 1000

 m["current_price"] = price

 # ä»·æ ¼å›è°ƒ
 if self.on_price_callback:
 self.on_price_callback(symbol, price, timestamp)

 # åˆå§‹åŒ–çª—å£
 if m["window_start_ms"] == 0:
 m["window_start_ms"] = now_ms
 m["window_start_price"] = price
 m["window_high"] = price
 m["window_low"] = price
 return

 # æ›´æ–°é«˜ä½ç‚¹
 m["window_high"] = max(m["window_high"], price)
 m["window_low"] = min(m["window_low"], price)

 # æ£€æµ‹çª—å£
 window_ms = now_ms - m["window_start_ms"]
 if window_ms >= SPIKE_CONFIG["price_window_ms"]:
 self._detect_spike(symbol, price, timestamp, m, now_ms)

 # é‡ç½®çª—å£
 m["window_start_ms"] = now_ms
 m["window_start_price"] = price
 m["window_high"] = price
 m["window_low"] = price

 def _detect_spike(self, symbol: str, price: float, timestamp: datetime, m: Dict, now_ms: float):
 start = m["window_start_price"]
 high = m["window_high"]
 low = m["window_low"]

 if start == 0:
 return

 # å†·å´æœŸ
 if now_ms - m["last_signal_time"] < 5000:
 return

 min_amp = SPIKE_CONFIG["min_spike_percent"]
 max_amp = SPIKE_CONFIG["max_spike_percent"]
 ret_threshold = SPIKE_CONFIG["initial_retracement_percent"]

 # è·å–å½“å‰è¶‹åŠ¿
 trend = self.trend_analyzer.get_trend(symbol, price)

 signal = None

 # ä¸Šæ’é’ˆ
 if high > start:
 up_amp = (high - start) / start * 100
 if min_amp <= up_amp <= max_amp:
 ret = (high - price) / (high - start) * 100
 if ret >= ret_threshold:
 signal = PinSignal(
 symbol=symbol,
 direction="UP",
 start_price=start,
 peak_price=high,
 current_price=price,
 amplitude=up_amp,
 retracement=ret,
 trend=trend,
 detected_at=timestamp
 )

 # ä¸‹æ’é’ˆ
 if signal is None and start > low:
 down_amp = (start - low) / start * 100
 if min_amp <= down_amp <= max_amp:
 ret = (price - low) / (start - low) * 100
 if ret >= ret_threshold:
 signal = PinSignal(
 symbol=symbol,
 direction="DOWN",
 start_price=start,
 peak_price=low,
 current_price=price,
 amplitude=down_amp,
 retracement=ret,
 trend=trend,
 detected_at=timestamp
 )

 if signal:
 m["last_signal_time"] = now_ms
 if self.on_signal_callback:
 self.on_signal_callback(signal)


# ============== äº¤æ˜“ç®¡ç†å™¨ ==============

class TradeManager:
 """äº¤æ˜“ç®¡ç†å™¨"""

 def __init__(self, client: BinanceFuturesClient, config: TestnetConfig):
 self.client = client
 self.config = config
 self.lock = threading.Lock()

 self.active_trades: Dict[str, TradePair] = {}
 self.completed_trades: List[TradePair] = []

 self.stats = {
 "total_signals": 0,
 "hedge_trades": 0,
 "single_trades": 0,
 "winning_trades": 0,
 "total_pnl": 0.0,
 }

 def on_signal(self, signal: PinSignal) -> bool:
 """å¤„ç†æ’é’ˆä¿¡å·"""
 with self.lock:
 self.stats["total_signals"] += 1

 if signal.symbol in self.active_trades:
 print(f"[{format_time()}] {signal.symbol} å·²æœ‰æŒä»“ï¼Œè·³è¿‡")
 return False

 if len(self.active_trades) >= STRATEGY_CONFIG["max_concurrent_trades"]:
 print(f"[{format_time()}] å·²è¾¾æœ€å¤§æŒä»“æ•°ï¼Œè·³è¿‡")
 return False

 # åˆ›å»ºäº¤æ˜“
 trade = TradePair(symbol=signal.symbol, signal=signal)

 # æ‰“å°ä¿¡å·ä¿¡æ¯
 self._print_signal(signal, trade)

 # å¼€å›è°ƒè…¿
 success = self._open_retracement_leg(trade)

 if success:
 self._calculate_targets(trade)

 with self.lock:
 self.active_trades[signal.symbol] = trade
 if trade.mode == TradeMode.HEDGE:
 self.stats["hedge_trades"] += 1
 else:
 self.stats["single_trades"] += 1

 self._print_trade_opened(trade)
 return True

 return False

 def on_price_update(self, symbol: str, price: float, timestamp: datetime):
 """å¤„ç†ä»·æ ¼æ›´æ–°"""
 with self.lock:
 if symbol not in self.active_trades:
 return
 trade = self.active_trades[symbol]

 if trade.mode == TradeMode.HEDGE:
 self._handle_hedge_mode(trade, price, timestamp)
 else:
 self._handle_single_mode(trade, price, timestamp)

 # ==================== å¼€ä»“é€»è¾‘ ====================

 def _open_retracement_leg(self, trade: TradePair) -> bool:
 """å¼€å›è°ƒè…¿"""
 try:
 signal = trade.signal
 price = signal.current_price

 quantity = self._calculate_quantity(trade.symbol, price)
 self.client.set_leverage(trade.symbol, self.config.LEVERAGE)

 side = "SELL" if trade.retracement_side == "SHORT" else "BUY"
 order = self.client.place_order(
 symbol=trade.symbol,
 side=side,
 order_type="MARKET",
 quantity=quantity,
 reduce_only=False
 )

 if order:
 trade.retracement_quantity = quantity
 trade.retracement_entry_price = float(order.get('avgPrice', 0)) or price
 return True

 except Exception as e:
 print(f"[{format_time()}] å¼€ä»“é”™è¯¯: {e}")

 return False

 def _open_trend_leg(self, trade: TradePair, price: float) -> bool:
 """å¼€è¶‹åŠ¿è…¿"""
 try:
 quantity = trade.retracement_quantity # ç›¸åŒæ•°é‡

 side = "BUY" if trade.trend_side == "LONG" else "SELL"
 order = self.client.place_order(
 symbol=trade.symbol,
 side=side,
 order_type="MARKET",
 quantity=quantity,
 reduce_only=False
 )

 if order:
 trade.trend_quantity = quantity
 trade.trend_entry_price = float(order.get('avgPrice', 0)) or price
 trade.state = TradeState.BOTH_OPEN

 print(f"\nğŸ¯ [{format_time()}] {trade.symbol} è¶‹åŠ¿è…¿å·²å¼€")
 print(f" æ–¹å‘: {trade.trend_side}")
 print(f" å…¥åœº: {trade.trend_entry_price:.6f}")
 print(f" æ­¢æŸ: {trade.trend_stop_loss:.6f}")
 print(f" æ­¢ç›ˆ: {trade.trend_take_profit:.6f}")

 return True

 except Exception as e:
 print(f"[{format_time()}] è¶‹åŠ¿è…¿å¼€ä»“é”™è¯¯: {e}")

 return False

 # ==================== ç›®æ ‡è®¡ç®— ====================

 def _calculate_targets(self, trade: TradePair):
 """è®¡ç®—ç›®æ ‡ä»·æ ¼"""
 signal = trade.signal
 leverage = self.config.LEVERAGE

 # å›è°ƒå¹…åº¦ = æ’é’ˆé¡¶éƒ¨åˆ°èµ·å§‹ä»·çš„è·ç¦»
 if signal.direction == "UP":
 spike_range = signal.peak_price - signal.start_price
 else:
 spike_range = signal.start_price - signal.peak_price

 if trade.mode == TradeMode.HEDGE:
 # å¯¹å†²æ¨¡å¼

 # è¶‹åŠ¿è…¿å¼€ä»“è§¦å‘ï¼ˆå›è°ƒ30%ï¼‰
 open_ret = STRATEGY_CONFIG["retracement_open_percent"] / 100
 # å›è°ƒè…¿å¹³ä»“ç›®æ ‡ï¼ˆå›è°ƒ60%ï¼‰
 close_ret = STRATEGY_CONFIG["retracement_close_percent"] / 100

 if signal.direction == "UP":
 # ä¸Šæ’é’ˆ + ä¸Šæ¶¨è¶‹åŠ¿
 # è¶‹åŠ¿è…¿å¼€ä»“ï¼šä»·æ ¼å›è°ƒ30%æ—¶å¼€å¤š
 trade.trend_open_trigger = signal.peak_price - spike_range * open_ret
 # å›è°ƒè…¿å¹³ä»“ï¼šä»·æ ¼å›è°ƒ60%æ—¶å¹³ç©º
 trade.retracement_target_close = signal.peak_price - spike_range * close_ret
 # è¶‹åŠ¿è…¿æ­¢æŸï¼šæ’é’ˆé¡¶éƒ¨ä¸Šæ–¹
 buffer = signal.peak_price * STRATEGY_CONFIG["stop_loss_buffer_percent"] / 100
 trade.trend_stop_loss = signal.peak_price + buffer
 # è¶‹åŠ¿è…¿æ­¢ç›ˆ
 tp_percent = STRATEGY_CONFIG["trend_initial_tp_percent"] / 100
 trade.trend_take_profit = trade.trend_open_trigger * (1 + tp_percent / leverage)
 else:
 # ä¸‹æ’é’ˆ + ä¸‹è·Œè¶‹åŠ¿
 # è¶‹åŠ¿è…¿å¼€ä»“ï¼šä»·æ ¼åå¼¹30%æ—¶å¼€ç©º
 trade.trend_open_trigger = signal.peak_price + spike_range * open_ret
 # å›è°ƒè…¿å¹³ä»“ï¼šä»·æ ¼åå¼¹60%æ—¶å¹³å¤š
 trade.retracement_target_close = signal.peak_price + spike_range * close_ret
 # è¶‹åŠ¿è…¿æ­¢æŸï¼šæ’é’ˆåº•éƒ¨ä¸‹æ–¹
 buffer = signal.peak_price * STRATEGY_CONFIG["stop_loss_buffer_percent"] / 100
 trade.trend_stop_loss = signal.peak_price - buffer
 # è¶‹åŠ¿è…¿æ­¢ç›ˆ
 tp_percent = STRATEGY_CONFIG["trend_initial_tp_percent"] / 100
 trade.trend_take_profit = trade.trend_open_trigger * (1 - tp_percent / leverage)

 else:
 # å•è¾¹æ¨¡å¼ - åªæœ‰å›è°ƒè…¿
 tp_percent = STRATEGY_CONFIG["single_leg_tp_percent"] / 100
 sl_percent = STRATEGY_CONFIG["single_leg_sl_percent"] / 100

 entry = trade.retracement_entry_price

 if trade.retracement_side == "SHORT":
 trade.retracement_target_close = entry * (1 - tp_percent / leverage)
 # æ­¢æŸåœ¨æ’é’ˆé¡¶éƒ¨
 buffer = signal.peak_price * STRATEGY_CONFIG["stop_loss_buffer_percent"] / 100
 trade.trend_stop_loss = signal.peak_price + buffer # å¤ç”¨æ­¤å­—æ®µä½œä¸ºæ­¢æŸ
 else:
 trade.retracement_target_close = entry * (1 + tp_percent / leverage)
 buffer = signal.peak_price * STRATEGY_CONFIG["stop_loss_buffer_percent"] / 100
 trade.trend_stop_loss = signal.peak_price - buffer

 # ==================== å¯¹å†²æ¨¡å¼å¤„ç† ====================

 def _handle_hedge_mode(self, trade: TradePair, price: float, timestamp: datetime):
 """å¤„ç†å¯¹å†²æ¨¡å¼"""

 if trade.state == TradeState.RETRACEMENT_OPEN:
 # ç­‰å¾…å¼€è¶‹åŠ¿è…¿
 self._check_trend_leg_trigger(trade, price, timestamp)
 self._check_retracement_stop_loss(trade, price)

 elif trade.state == TradeState.BOTH_OPEN:
 # åŒè…¿éƒ½å¼€ï¼Œæ£€æŸ¥å¹³ä»“
 self._check_retracement_close(trade, price)
 self._check_trend_trailing(trade, price)

 elif trade.state == TradeState.RETRACEMENT_CLOSED:
 # å›è°ƒè…¿å·²å¹³ï¼Œç®¡ç†è¶‹åŠ¿è…¿
 self._check_trend_exit(trade, price, timestamp)

 def _check_trend_leg_trigger(self, trade: TradePair, price: float, timestamp: datetime):
 """æ£€æŸ¥æ˜¯å¦è§¦å‘å¼€è¶‹åŠ¿è…¿"""
 # è¶…æ—¶æ£€æŸ¥
 elapsed = (timestamp - trade.created_at).total_seconds()
 if elapsed > STRATEGY_CONFIG["retracement_timeout_seconds"]:
 print(f"\nâ° [{format_time()}] {trade.symbol} ç­‰å¾…è¶…æ—¶ï¼Œè½¬ä¸ºå•è¾¹ç®¡ç†")
 trade.mode = TradeMode.SINGLE
 trade.

---
## ğŸ§‘â€ğŸ’» User

è¾“å‡ºä¸­æ–­äº†ï¼Œè¯·ä½ è¡¥å……

---
## ğŸ¤– Assistant

å¥½çš„ï¼Œæˆ‘ç»§ç»­è¡¥å……å®Œæ•´ä»£ç ï¼š

```python
    def _check_trend_leg_trigger(self, trade: TradePair, price: float, timestamp: datetime):
        """æ£€æŸ¥æ˜¯å¦è§¦å‘å¼€è¶‹åŠ¿è…¿"""
        # è¶…æ—¶æ£€æŸ¥
        elapsed = (timestamp - trade.created_at).total_seconds()
        if elapsed > STRATEGY_CONFIG["retracement_timeout_seconds"]:
            print(f"\nâ° [{format_time()}] {trade.symbol} ç­‰å¾…è¶…æ—¶ï¼Œè½¬ä¸ºå•è¾¹ç®¡ç†")
            trade.mode = TradeMode.SINGLE
            trade.state = TradeState.SINGLE_OPEN
            return
        
        # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¼€ä»“è§¦å‘ä»·
        signal = trade.signal
        should_open = False
        
        if signal.direction == "UP":
            # ä¸Šæ’é’ˆï¼Œç­‰ä»·æ ¼ç»§ç»­ä¸‹è·Œåˆ°è§¦å‘ä»·
            if price <= trade.trend_open_trigger:
                should_open = True
        else:
            # ä¸‹æ’é’ˆï¼Œç­‰ä»·æ ¼ç»§ç»­ä¸Šæ¶¨åˆ°è§¦å‘ä»·
            if price >= trade.trend_open_trigger:
                should_open = True
        
        if should_open:
            success = self._open_trend_leg(trade, price)
            if not success:
                # å¼€ä»“å¤±è´¥ï¼Œè½¬ä¸ºå•è¾¹
                trade.mode = TradeMode.SINGLE
                trade.state = TradeState.SINGLE_OPEN
    
    def _check_retracement_stop_loss(self, trade: TradePair, price: float):
        """æ£€æŸ¥å›è°ƒè…¿æ­¢æŸï¼ˆè¶‹åŠ¿è…¿æœªå¼€æ—¶ï¼‰"""
        signal = trade.signal
        
        # æ­¢æŸåœ¨æ’é’ˆé¡¶/åº•éƒ¨
        if trade.retracement_side == "SHORT":
            # ç©ºå•æ­¢æŸï¼šä»·æ ¼å›åˆ°æ’é’ˆé¡¶éƒ¨ä¸Šæ–¹
            buffer = signal.peak_price * STRATEGY_CONFIG["stop_loss_buffer_percent"] / 100
            if price >= signal.peak_price + buffer:
                self._close_retracement_leg(trade, price, "stop_loss")
                self._finalize_trade(trade, "retracement_stop_loss")
        else:
            # å¤šå•æ­¢æŸï¼šä»·æ ¼å›åˆ°æ’é’ˆåº•éƒ¨ä¸‹æ–¹
            buffer = signal.peak_price * STRATEGY_CONFIG["stop_loss_buffer_percent"] / 100
            if price <= signal.peak_price - buffer:
                self._close_retracement_leg(trade, price, "stop_loss")
                self._finalize_trade(trade, "retracement_stop_loss")
    
    def _check_retracement_close(self, trade: TradePair, price: float):
        """æ£€æŸ¥å›è°ƒè…¿æ˜¯å¦åº”è¯¥å¹³ä»“"""
        if trade.retracement_closed:
            return
        
        should_close = False
        
        if trade.retracement_side == "SHORT":
            # ç©ºå•ï¼šä»·æ ¼è·Œåˆ°ç›®æ ‡ä»·å¹³ä»“
            if price <= trade.retracement_target_close:
                should_close = True
        else:
            # å¤šå•ï¼šä»·æ ¼æ¶¨åˆ°ç›®æ ‡ä»·å¹³ä»“
            if price >= trade.retracement_target_close:
                should_close = True
        
        if should_close:
            self._close_retracement_leg(trade, price, "take_profit")
            trade.state = TradeState.RETRACEMENT_CLOSED
            
            print(f"\nâœ… [{format_time()}] {trade.symbol} å›è°ƒè…¿å·²å¹³ä»“")
            print(f"   ç›ˆäº: {trade.retracement_pnl:+.4f} USDT")
            print(f"   è¶‹åŠ¿è…¿ç»§ç»­æŒæœ‰...")
    
    def _check_trend_trailing(self, trade: TradePair, price: float):
        """æ£€æŸ¥è¶‹åŠ¿è…¿è·Ÿè¸ªæ­¢æŸï¼ˆåŒè…¿éƒ½å¼€æ—¶ï¼‰"""
        if trade.trend_closed:
            return
        
        # è®¡ç®—å½“å‰æµ®ç›ˆ%
        leverage = self.config.LEVERAGE
        if trade.trend_side == "LONG":
            profit_percent = (price - trade.trend_entry_price) / trade.trend_entry_price * 100 * leverage
        else:
            profit_percent = (trade.trend_entry_price - price) / trade.trend_entry_price * 100 * leverage
        
        # æ›´æ–°æœ€é«˜æµ®ç›ˆ
        if profit_percent > trade.trend_highest_profit:
            trade.trend_highest_profit = profit_percent
            
            # ç›ˆåˆ©è¶…è¿‡åˆå§‹ç›®æ ‡ï¼Œæé«˜æ­¢ç›ˆ
            if profit_percent >= STRATEGY_CONFIG["trend_initial_tp_percent"]:
                self._update_trend_take_profit(trade, price)
        
        # æ­¢æŸæ£€æŸ¥ï¼ˆæ’é’ˆé¡¶/åº•éƒ¨ï¼‰
        if trade.trend_side == "LONG":
            if price <= trade.trend_stop_loss:
                self._close_trend_leg(trade, price, "stop_loss")
        else:
            if price >= trade.trend_stop_loss:
                self._close_trend_leg(trade, price, "stop_loss")
    
    def _check_trend_exit(self, trade: TradePair, price: float, timestamp: datetime):
        """æ£€æŸ¥è¶‹åŠ¿è…¿é€€å‡ºï¼ˆå›è°ƒè…¿å·²å¹³åï¼‰"""
        if trade.trend_closed:
            return
        
        leverage = self.config.LEVERAGE
        
        # è®¡ç®—å½“å‰æµ®ç›ˆ
        if trade.trend_side == "LONG":
            profit_percent = (price - trade.trend_entry_price) / trade.trend_entry_price * 100 * leverage
        else:
            profit_percent = (trade.trend_entry_price - price) / trade.trend_entry_price * 100 * leverage
        
        # æ›´æ–°æœ€é«˜æµ®ç›ˆ
        if profit_percent > trade.trend_highest_profit:
            trade.trend_highest_profit = profit_percent
            self._update_trend_take_profit(trade, price)
        
        # æ­¢æŸæ£€æŸ¥
        if trade.trend_side == "LONG":
            if price <= trade.trend_stop_loss:
                self._close_trend_leg(trade, price, "stop_loss")
                self._finalize_trade(trade, "trend_stop_loss")
                return
        else:
            if price >= trade.trend_stop_loss:
                self._close_trend_leg(trade, price, "stop_loss")
                self._finalize_trade(trade, "trend_stop_loss")
                return
        
        # æ­¢ç›ˆæ£€æŸ¥
        if trade.trend_side == "LONG":
            if price >= trade.trend_take_profit:
                self._close_trend_leg(trade, price, "take_profit")
                self._finalize_trade(trade, "trend_take_profit")
                return
        else:
            if price <= trade.trend_take_profit:
                self._close_trend_leg(trade, price, "take_profit")
                self._finalize_trade(trade, "trend_take_profit")
                return
        
        # è·Ÿè¸ªæ­¢æŸï¼šä»æœ€é«˜ç›ˆåˆ©å›æ’¤
        trailing = STRATEGY_CONFIG["trend_trailing_callback"]
        if trade.trend_highest_profit > trailing:
            if trade.trend_highest_profit - profit_percent >= trailing:
                self._close_trend_leg(trade, price, "trailing_stop")
                self._finalize_trade(trade, "trend_trailing_stop")
                return
        
        # è¶…æ—¶æ£€æŸ¥
        elapsed = (timestamp - trade.created_at).total_seconds()
        if elapsed > STRATEGY_CONFIG["trend_max_hold_seconds"]:
            self._close_trend_leg(trade, price, "timeout")
            self._finalize_trade(trade, "trend_timeout")
    
    def _update_trend_take_profit(self, trade: TradePair, price: float):
        """æ›´æ–°è¶‹åŠ¿è…¿æ­¢ç›ˆç›®æ ‡"""
        leverage = self.config.LEVERAGE
        extended_tp = STRATEGY_CONFIG["trend_extended_tp_percent"] / 100
        
        if trade.trend_side == "LONG":
            new_tp = trade.trend_entry_price * (1 + extended_tp / leverage)
            if new_tp > trade.trend_take_profit:
                trade.trend_take_profit = new_tp
        else:
            new_tp = trade.trend_entry_price * (1 - extended_tp / leverage)
            if new_tp < trade.trend_take_profit:
                trade.trend_take_profit = new_tp
    
    # ==================== å•è¾¹æ¨¡å¼å¤„ç† ====================
    
    def _handle_single_mode(self, trade: TradePair, price: float, timestamp: datetime):
        """å¤„ç†å•è¾¹æ¨¡å¼"""
        if trade.retracement_closed:
            return
        
        # æ­¢ç›ˆæ£€æŸ¥
        if trade.retracement_side == "SHORT":
            if price <= trade.retracement_target_close:
                self._close_retracement_leg(trade, price, "take_profit")
                self._finalize_trade(trade, "single_take_profit")
                return
        else:
            if price >= trade.retracement_target_close:
                self._close_retracement_leg(trade, price, "take_profit")
                self._finalize_trade(trade, "single_take_profit")
                return
        
        # æ­¢æŸæ£€æŸ¥
        if trade.retracement_side == "SHORT":
            if price >= trade.trend_stop_loss:  # å¤ç”¨æ­¤å­—æ®µ
                self._close_retracement_leg(trade, price, "stop_loss")
                self._finalize_trade(trade, "single_stop_loss")
                return
        else:
            if price <= trade.trend_stop_loss:
                self._close_retracement_leg(trade, price, "stop_loss")
                self._finalize_trade(trade, "single_stop_loss")
                return
        
        # è¶…æ—¶æ£€æŸ¥
        elapsed = (timestamp - trade.created_at).total_seconds()
        if elapsed > STRATEGY_CONFIG["retracement_timeout_seconds"] * 2:
            self._close_retracement_leg(trade, price, "timeout")
            self._finalize_trade(trade, "single_timeout")
    
    # ==================== å¹³ä»“é€»è¾‘ ====================
    
    def _close_retracement_leg(self, trade: TradePair, price: float, reason: str):
        """å¹³å›è°ƒè…¿"""
        if trade.retracement_closed:
            return
        
        try:
            side = "BUY" if trade.retracement_side == "SHORT" else "SELL"
            order = self.client.place_order(
                symbol=trade.symbol,
                side=side,
                order_type="MARKET",
                quantity=trade.retracement_quantity,
                reduce_only=True
            )
            
            if order:
                exit_price = float(order.get('avgPrice', 0)) or price
                trade.retracement_closed = True
                
                # è®¡ç®—ç›ˆäº
                if trade.retracement_side == "SHORT":
                    pnl_percent = (trade.retracement_entry_price - exit_price) / trade.retracement_entry_price
                else:
                    pnl_percent = (exit_price - trade.retracement_entry_price) / trade.retracement_entry_price
                
                trade.retracement_pnl = self.config.POSITION_USDT * pnl_percent * self.config.LEVERAGE
                trade.retracement_pnl -= self.config.POSITION_USDT * self.config.FEE_RATE * 2
                
                print(f"\nğŸ“¤ [{format_time()}] {trade.symbol} å›è°ƒè…¿å¹³ä»“ ({reason})")
                print(f"   {trade.retracement_side}: {trade.retracement_entry_price:.6f} â†’ {exit_price:.6f}")
                print(f"   ç›ˆäº: {trade.retracement_pnl:+.4f} USDT")
                
        except Exception as e:
            print(f"[{format_time()}] å¹³ä»“é”™è¯¯: {e}")
    
    def _close_trend_leg(self, trade: TradePair, price: float, reason: str):
        """å¹³è¶‹åŠ¿è…¿"""
        if trade.trend_closed or trade.trend_quantity == 0:
            return
        
        try:
            side = "SELL" if trade.trend_side == "LONG" else "BUY"
            order = self.client.place_order(
                symbol=trade.symbol,
                side=side,
                order_type="MARKET",
                quantity=trade.trend_quantity,
                reduce_only=True
            )
            
            if order:
                exit_price = float(order.get('avgPrice', 0)) or price
                trade.trend_closed = True
                
                # è®¡ç®—ç›ˆäº
                if trade.trend_side == "LONG":
                    pnl_percent = (exit_price - trade.trend_entry_price) / trade.trend_entry_price
                else:
                    pnl_percent = (trade.trend_entry_price - exit_price) / trade.trend_entry_price
                
                trade.trend_pnl = self.config.POSITION_USDT * pnl_percent * self.config.LEVERAGE
                trade.trend_pnl -= self.config.POSITION_USDT * self.config.FEE_RATE * 2
                
                print(f"\nğŸ“¤ [{format_time()}] {trade.symbol} è¶‹åŠ¿è…¿å¹³ä»“ ({reason})")
                print(f"   {trade.trend_side}: {trade.trend_entry_price:.6f} â†’ {exit_price:.6f}")
                print(f"   ç›ˆäº: {trade.trend_pnl:+.4f} USDT")
                
        except Exception as e:
            print(f"[{format_time()}] å¹³ä»“é”™è¯¯: {e}")
    
    def _finalize_trade(self, trade: TradePair, reason: str):
        """å®Œæˆäº¤æ˜“"""
        trade.total_pnl = trade.retracement_pnl + trade.trend_pnl
        trade.close_reason = reason
        trade.closed_at = get_beijing_time()
        trade.state = TradeState.CLOSED
        
        with self.lock:
            if trade.symbol in self.active_trades:
                del self.active_trades[trade.symbol]
            self.completed_trades.append(trade)
            
            self.stats["total_pnl"] += trade.total_pnl
            if trade.total_pnl > 0:
                self.stats["winning_trades"] += 1
        
        # æ‰“å°ç»“æœ
        pnl_color = "\033[92m" if trade.total_pnl > 0 else "\033[91m"
        reset = "\033[0m"
        
        print(f"\n{'='*60}")
        print(f"äº¤æ˜“å®Œæˆ: {trade.symbol}")
        print(f"   æ¨¡å¼: {trade.mode.value}")
        print(f"   å›è°ƒè…¿ç›ˆäº: {trade.retracement_pnl:+.4f} USDT")
        if trade.mode == TradeMode.HEDGE:
            print(f"   è¶‹åŠ¿è…¿ç›ˆäº: {trade.trend_pnl:+.4f} USDT")
        print(f"   æ€»ç›ˆäº: {pnl_color}{trade.total_pnl:+.4f} USDT{reset}")
        print(f"   åŸå› : {reason}")
        print(f"{'='*60}")
    
    # ==================== è¾…åŠ©æ–¹æ³• ====================
    
    def _calculate_quantity(self, symbol: str, price: float) -> float:
        """è®¡ç®—ä¸‹å•æ•°é‡"""
        quantity = (self.config.POSITION_USDT * self.config.LEVERAGE) / price
        precision = self._get_precision(symbol)
        return round(quantity, precision)
    
    def _get_precision(self, symbol: str) -> int:
        """è·å–ç²¾åº¦"""
        precision_map = {
            "BTCUSDT": 3, "ETHUSDT": 3, "BNBUSDT": 2,
            "SOLUSDT": 1, "XRPUSDT": 1, "DOGEUSDT": 0,
            "TRUMPUSDT": 1, "AAVEUSDT": 2,
        }
        return precision_map.get(symbol, 3)
    
    def _print_signal(self, signal: PinSignal, trade: TradePair):
        """æ‰“å°ä¿¡å·ä¿¡æ¯"""
        print(f"\n{'='*60}")
        print(f"ğŸ”” [{format_time()}] æ’é’ˆä¿¡å·")
        print(f"   äº¤æ˜“å¯¹: {signal.symbol}")
        print(f"   æ–¹å‘: {'ä¸Šæ’é’ˆ ğŸ”º' if signal.direction == 'UP' else 'ä¸‹æ’é’ˆ ğŸ”»'}")
        print(f"   å¹…åº¦: {signal.amplitude:.2f}%")
        print(f"   å›æ’¤: {signal.retracement:.1f}%")
        print(f"   è¶‹åŠ¿: {'ä¸Šæ¶¨ğŸ“ˆ' if signal.trend == Trend.UP else 'ä¸‹è·ŒğŸ“‰' if signal.trend == Trend.DOWN else 'ä¸­æ€§â¡ï¸'}")
        print(f"   æ¨¡å¼: {'å¯¹å†²åŒè…¿' if trade.mode == TradeMode.HEDGE else 'å•è¾¹'}")
        print(f"{'='*60}")
    
    def _print_trade_opened(self, trade: TradePair):
        """æ‰“å°å¼€ä»“ä¿¡æ¯"""
        print(f"\nâœ… [{format_time()}] {trade.symbol} å›è°ƒè…¿å·²å¼€")
        print(f"   æ–¹å‘: {trade.retracement_side}")
        print(f"   å…¥åœº: {trade.retracement_entry_price:.6f}")
        print(f"   æ•°é‡: {trade.retracement_quantity:.6f}")
        
        if trade.mode == TradeMode.HEDGE:
            print(f"   è¶‹åŠ¿è…¿è§¦å‘ä»·: {trade.trend_open_trigger:.6f}")
            print(f"   å›è°ƒè…¿ç›®æ ‡å¹³ä»“: {trade.retracement_target_close:.6f}")
        else:
            print(f"   æ­¢ç›ˆç›®æ ‡: {trade.retracement_target_close:.6f}")
            print(f"   æ­¢æŸ: {trade.trend_stop_loss:.6f}")
    
    def close_all(self, reason: str = "manual"):
        """å¹³æ‰æ‰€æœ‰æŒä»“"""
        with self.lock:
            trades = list(self.active_trades.values())
        
        for trade in trades:
            price = self.client.get_market_price(trade.symbol) or trade.retracement_entry_price
            
            if not trade.retracement_closed:
                self._close_retracement_leg(trade, price, reason)
            
            if trade.mode == TradeMode.HEDGE and not trade.trend_closed and trade.trend_quantity > 0:
                self._close_trend_leg(trade, price, reason)
            
            self._finalize_trade(trade, reason)
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡"""
        total = self.stats["hedge_trades"] + self.stats["single_trades"]
        win_rate = (self.stats["winning_trades"] / total * 100) if total > 0 else 0
        return {
            **self.stats,
            "active_trades": len(self.active_trades),
            "completed_trades": len(self.completed_trades),
            "win_rate": win_rate,
        }


# ============== è¿è¡Œå™¨ ==============

class StrategyRunner:
    """ç­–ç•¥è¿è¡Œå™¨"""
    
    def __init__(self, config: TestnetConfig = None):
        self.config = config or load_config()
        self.running = False
        
        # åˆå§‹åŒ–å®¢æˆ·ç«¯
        self.client = BinanceFuturesClient(
            api_key=self.config.BINANCE_API_KEY,
            api_secret=self.config.BINANCE_API_SECRET,
            testnet=True,
            timeout=self.config.API_TIMEOUT,
            enable_proxy=self.config.ENABLE_PROXY,
            proxy_url=self.config.PROXY_URL if self.config.ENABLE_PROXY else None
        )
        
        # åˆå§‹åŒ–ç»„ä»¶
        self.trend_analyzer = TrendAnalyzer()
        self.trade_manager = TradeManager(self.client, self.config)
        
        self._start_time = None
    
    def start(self, symbols: List[str] = None):
        """å¯åŠ¨"""
        symbols = symbols or DEFAULT_SYMBOLS
        
        # æµ‹è¯•è¿æ¥
        print("\nğŸ”— æµ‹è¯•è¿æ¥...")
        if not self.client.test_connectivity():
            print("âŒ è¿æ¥å¤±è´¥")
            return
        
        account = self.client.get_account_info()
        if not account:
            print("âŒ è·å–è´¦æˆ·å¤±è´¥")
            return
        
        print(f"âœ… è¿æ¥æˆåŠŸï¼Œä½™é¢: {account.available_balance:.2f} USDT")
        
        # å¯åŠ¨æ£€æµ‹å™¨
        self.detector = PinDetector(symbols, self.trend_analyzer)
        self.detector.set_callbacks(
            on_signal=self.trade_manager.on_signal,
            on_price=self.trade_manager.on_price_update
        )
        self.detector.start()
        
        self.running = True
        self._start_time = time.time()
        
        # æ‰“å°é…ç½®
        self._print_config(symbols)
        
        # ä¿¡å·å¤„ç†
        signal.signal(signal.SIGINT, self._signal_handler)
        
        # ä¸»å¾ªç¯
        try:
            last_status = 0
            while self.running:
                time.sleep(0.1)
                
                now = time.time()
                if now - last_status >= 30:
                    self._print_status()
                    last_status = now
                    
        except KeyboardInterrupt:
            pass
        finally:
            self.stop()
    
    def _print_config(self, symbols: List[str]):
        """æ‰“å°é…ç½®"""
        print("\n" + "=" * 70)
        print("          æ’é’ˆå¯¹å†²ç­–ç•¥è¿è¡Œå™¨ï¼ˆæµ‹è¯•ç½‘ï¼‰")
        print("=" * 70)
        print(f"ç›‘æ§: {', '.join(symbols)}")
        print(f"ä»“ä½: {self.config.POSITION_USDT} USDT Ã— {self.config.LEVERAGE}x")
        print("-" * 70)
        print("ç­–ç•¥å‚æ•°:")
        print(f"   å›è°ƒå¼€ä»“: {STRATEGY_CONFIG['retracement_open_percent']}%")
        print(f"   å›è°ƒå¹³ä»“: {STRATEGY_CONFIG['retracement_close_percent']}%")
        print(f"   è¶‹åŠ¿æ­¢ç›ˆ: {STRATEGY_CONFIG['trend_initial_tp_percent']}% â†’ {STRATEGY_CONFIG['trend_extended_tp_percent']}%")
        print(f"   è·Ÿè¸ªæ­¢æŸ: {STRATEGY_CONFIG['trend_trailing_callback']}%")
        print("-" * 70)
        print("ç­–ç•¥è¯´æ˜:")
        print("   ä¸Šæ’é’ˆ+ä¸Šæ¶¨è¶‹åŠ¿: é¡¶éƒ¨å¼€ç©º(åƒå›è°ƒ) â†’ å¼€å¤š(é¡ºè¶‹åŠ¿) â†’ å…ˆå¹³ç©º â†’ å¤šå•æŒæœ‰")
        print("   ä¸Šæ’é’ˆ+ä¸‹è·Œè¶‹åŠ¿: é¡¶éƒ¨å¼€ç©º(å•è¾¹)")
        print("   ä¸‹æ’é’ˆ+ä¸‹è·Œè¶‹åŠ¿: åº•éƒ¨å¼€å¤š(åƒåå¼¹) â†’ å¼€ç©º(é¡ºè¶‹åŠ¿) â†’ å…ˆå¹³å¤š â†’ ç©ºå•æŒæœ‰")
        print("   ä¸‹æ’é’ˆ+ä¸Šæ¶¨è¶‹åŠ¿: åº•éƒ¨å¼€å¤š(å•è¾¹)")
        print("=" * 70)
    
    def _print_status(self):
        """æ‰“å°çŠ¶æ€"""
        if not self.running:
            return
        
        elapsed = time.time() - self._start_time
        stats = self.trade_manager.get_stats()
        
        print(f"\n{'â”€'*60}")
        print(f"ğŸ“Š è¿è¡Œ: {elapsed/60:.1f}åˆ†é’Ÿ | WS: {'ğŸŸ¢' if self.detector.ws_connected else 'ğŸ”´'}")
        print(f"   ä¿¡å·: {stats['total_signals']} | å¯¹å†²: {stats['hedge_trades']} | å•è¾¹: {stats['single_trades']}")
        print(f"   æ´»è·ƒ: {stats['active_trades']} | å®Œæˆ: {stats['completed_trades']}")
        
        if stats['completed_trades'] > 0:
            pnl_color = "\033[92m" if stats['total_pnl'] > 0 else "\033[91m"
            reset = "\033[0m"
            print(f"   èƒœç‡: {stats['win_rate']:.1f}% | ç›ˆäº: {pnl_color}{stats['total_pnl']:+.4f} USDT{reset}")
        
        print(f"{'â”€'*60}")
    
    def stop(self):
        """åœæ­¢"""
        if not self.running:
            return
        
        print("\n\nğŸ›‘ åœæ­¢ä¸­...")
        self.running = False
        
        if hasattr(self, 'detector'):
            self.detector.stop()
        
        # å¹³ä»“
        stats = self.trade_manager.get_stats()
        if stats['active_trades'] > 0:
            print(f"ğŸ“¤ å¹³ä»“ {stats['active_trades']} ä¸ªæŒä»“...")
            self.trade_manager.close_all("shutdown")
        
        self._print_final()
    
    def _print_final(self):
        """æ‰“å°æœ€ç»ˆç»Ÿè®¡"""
        stats = self.trade_manager.get_stats()
        elapsed = time.time() - self._start_time if self._start_time else 0
        
        print("\n" + "=" * 60)
        print("                    æœ€ç»ˆç»Ÿè®¡")
        print("=" * 60)
        print(f"   è¿è¡Œæ—¶é•¿: {elapsed/60:.1f}åˆ†é’Ÿ")
        print(f"   æ€»ä¿¡å·: {stats['total_signals']}")
        print(f"   å¯¹å†²äº¤æ˜“: {stats['hedge_trades']}")
        print(f"   å•è¾¹äº¤æ˜“: {stats['single_trades']}")
        
        total = stats['hedge_trades'] + stats['single_trades']
        if total > 0:
            pnl_color = "\033[92m" if stats['total_pnl'] > 0 else "\033[91m"
            reset = "\033[0m"
            print(f"   èƒœç‡: {stats['win_rate']:.1f}%")
            print(f"   æ€»ç›ˆäº: {pnl_color}{stats['total_pnl']:+.4f} USDT{reset}")
        
        print("=" * 60)
    
    def _signal_handler(self, signum, frame):
        self.stop()
        sys.exit(0)


# ============== ä¸»å‡½æ•° ==============

def main():
    print("=" * 60)
    print("     Flash Arbitrage Bot - æ’é’ˆå¯¹å†²ç­–ç•¥")
    print("=" * 60)
    
    try:
        config = load_config()
    except ValueError as e:
        print(f"\nâŒ é…ç½®é”™è¯¯: {e}")
        return
    
    runner = StrategyRunner(config)
    runner.start(DEFAULT_SYMBOLS)


if __name__ == "__main__":
    main()
```

è¿™ä¸ªå®Œæ•´ç‰ˆæœ¬å®ç°äº†ï¼š

## ç­–ç•¥é€»è¾‘æ€»ç»“

| æƒ…å†µ | æ“ä½œ |
|------|------|
| **ä¸Šæ’é’ˆ + ä¸Šæ¶¨è¶‹åŠ¿** | é¡¶éƒ¨å¼€ç©º(åƒå›è°ƒ) â†’ å›è°ƒæ—¶å¼€å¤š(é¡ºè¶‹åŠ¿) â†’ å…ˆå¹³ç©º â†’ å¤šå•ç»§ç»­æŒæœ‰ |
| **ä¸Šæ’é’ˆ + ä¸‹è·Œ/ä¸­æ€§è¶‹åŠ¿** | é¡¶éƒ¨å¼€ç©º(å•è¾¹æ¨¡å¼) |
| **ä¸‹æ’é’ˆ + ä¸‹è·Œè¶‹åŠ¿** | åº•éƒ¨å¼€å¤š(åƒåå¼¹) â†’ åå¼¹æ—¶å¼€ç©º(é¡ºè¶‹åŠ¿) â†’ å…ˆå¹³å¤š â†’ ç©ºå•ç»§ç»­æŒæœ‰ |
| **ä¸‹æ’é’ˆ + ä¸Šæ¶¨/ä¸­æ€§è¶‹åŠ¿** | åº•éƒ¨å¼€å¤š(å•è¾¹æ¨¡å¼) |

## å…³é”®å‚æ•°

- å›è°ƒ30%æ—¶å¼€è¶‹åŠ¿è…¿
- å›è°ƒ60%æ—¶å¹³å›è°ƒè…¿ï¼ˆé”å®šåˆ©æ¶¦ï¼‰
- è¶‹åŠ¿è…¿æ­¢æŸè®¾åœ¨æ’é’ˆé¡¶/åº•éƒ¨
- è¶‹åŠ¿è…¿æœ‰è·Ÿè¸ªæ­¢æŸåŠŸèƒ½
